// Code generated by codecgen - DO NOT EDIT.

package xlsx

import (
	pkg1_xml "encoding/xml"
	"errors"
	codec1978 "github.com/ugorji/go/codec"
	"runtime"
	"strconv"
	"sync"
	"time"
)

const (
	// ----- content types ----
	codecSelferCcUTF81 = 1
	codecSelferCcRAW1  = 0
	// ----- value types used ----
	codecSelferValueTypeArray1  = 10
	codecSelferValueTypeMap1    = 9
	codecSelferValueTypeString1 = 6
	codecSelferValueTypeInt1    = 2
	codecSelferValueTypeUint1   = 3
	codecSelferValueTypeFloat1  = 4
	codecSelferBitsize1         = uint8(32 << (^uint(0) >> 63))
)

var (
	errCodecSelferOnlyMapOrArrayEncodeToStruct1 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer1 struct{}

func init() {
	if codec1978.GenVersion != 8 {
		_, file, _, _ := runtime.Caller(0)
		panic("codecgen version mismatch: current: 8, need " + strconv.FormatInt(int64(codec1978.GenVersion), 10) + ". Re-generate file: " + file)
	}
	if false { // reference the types, but skip this branch at build/run time
		var v0 pkg1_xml.Name
		var v1 sync.RWMutex
		var v2 time.Location
		_, _, _ = v0, v1, v2
	}
}

func (x *RefTable) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *RefTable) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *RefTable) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *RefTable) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *XLSXReaderError) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Err))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Err`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Err))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *XLSXReaderError) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *XLSXReaderError) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Err":
			if r.TryDecodeAsNil() {
				x.Err = ""
			} else {
				x.Err = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *XLSXReaderError) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Err = ""
	} else {
		x.Err = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *sharedFormula) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *sharedFormula) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *sharedFormula) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *sharedFormula) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *indexedSheet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Index))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Index`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Index))
				}
			}
			var yyn6 bool
			if x.Sheet == nil {
				yyn6 = true
				goto LABEL6
			}
		LABEL6:
			if yyr2 || yy2arr2 {
				if yyn6 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Sheet == nil {
						r.EncodeNil()
					} else {
						x.Sheet.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sheet`)
				r.WriteMapElemValue()
				if yyn6 {
					r.EncodeNil()
				} else {
					if x.Sheet == nil {
						r.EncodeNil()
					} else {
						x.Sheet.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Error == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						z.EncFallback(x.Error)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Error`)
				r.WriteMapElemValue()
				if x.Error == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						z.EncFallback(x.Error)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *indexedSheet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *indexedSheet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Index":
			if r.TryDecodeAsNil() {
				x.Index = 0
			} else {
				x.Index = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Sheet":
			if r.TryDecodeAsNil() {
				if true && x.Sheet != nil {
					x.Sheet = nil
				}
			} else {
				if x.Sheet == nil {
					x.Sheet = new(Sheet)
				}

				x.Sheet.CodecDecodeSelf(d)
			}
		case "Error":
			if r.TryDecodeAsNil() {
				x.Error = nil
			} else {
				if false {
				} else {
					z.DecFallback(&x.Error, true)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *indexedSheet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Index = 0
	} else {
		x.Index = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Sheet != nil {
			x.Sheet = nil
		}
	} else {
		if x.Sheet == nil {
			x.Sheet = new(Sheet)
		}

		x.Sheet.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Error = nil
	} else {
		if false {
		} else {
			z.DecFallback(&x.Error, true)
		}
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x WorkBookRels) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			h.encWorkBookRels((WorkBookRels)(x), e)
		}
	}
}

func (x *WorkBookRels) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		h.decWorkBookRels((*WorkBookRels)(x), d)
	}
}

func (x *xlsxWorksheet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(13)
			} else {
				r.WriteMapStart(13)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy9 := &x.SheetPr
				yy9.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetPr`)
				r.WriteMapElemValue()
				yy11 := &x.SheetPr
				yy11.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy14 := &x.Dimension
				yy14.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Dimension`)
				r.WriteMapElemValue()
				yy16 := &x.Dimension
				yy16.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy19 := &x.SheetViews
				yy19.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetViews`)
				r.WriteMapElemValue()
				yy21 := &x.SheetViews
				yy21.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy24 := &x.SheetFormatPr
				yy24.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetFormatPr`)
				r.WriteMapElemValue()
				yy26 := &x.SheetFormatPr
				yy26.CodecEncodeSelf(e)
			}
			var yyn28 bool
			if x.Cols == nil {
				yyn28 = true
				goto LABEL28
			}
		LABEL28:
			if yyr2 || yy2arr2 {
				if yyn28 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Cols == nil {
						r.EncodeNil()
					} else {
						x.Cols.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Cols`)
				r.WriteMapElemValue()
				if yyn28 {
					r.EncodeNil()
				} else {
					if x.Cols == nil {
						r.EncodeNil()
					} else {
						x.Cols.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy32 := &x.SheetData
				yy32.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetData`)
				r.WriteMapElemValue()
				yy34 := &x.SheetData
				yy34.CodecEncodeSelf(e)
			}
			var yyn36 bool
			if x.AutoFilter == nil {
				yyn36 = true
				goto LABEL36
			}
		LABEL36:
			if yyr2 || yy2arr2 {
				if yyn36 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.AutoFilter == nil {
						r.EncodeNil()
					} else {
						x.AutoFilter.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `AutoFilter`)
				r.WriteMapElemValue()
				if yyn36 {
					r.EncodeNil()
				} else {
					if x.AutoFilter == nil {
						r.EncodeNil()
					} else {
						x.AutoFilter.CodecEncodeSelf(e)
					}
				}
			}
			var yyn39 bool
			if x.MergeCells == nil {
				yyn39 = true
				goto LABEL39
			}
		LABEL39:
			if yyr2 || yy2arr2 {
				if yyn39 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.MergeCells == nil {
						r.EncodeNil()
					} else {
						x.MergeCells.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `MergeCells`)
				r.WriteMapElemValue()
				if yyn39 {
					r.EncodeNil()
				} else {
					if x.MergeCells == nil {
						r.EncodeNil()
					} else {
						x.MergeCells.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy43 := &x.PrintOptions
				yy43.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PrintOptions`)
				r.WriteMapElemValue()
				yy45 := &x.PrintOptions
				yy45.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy48 := &x.PageMargins
				yy48.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PageMargins`)
				r.WriteMapElemValue()
				yy50 := &x.PageMargins
				yy50.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy53 := &x.PageSetUp
				yy53.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PageSetUp`)
				r.WriteMapElemValue()
				yy55 := &x.PageSetUp
				yy55.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy58 := &x.HeaderFooter
				yy58.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `HeaderFooter`)
				r.WriteMapElemValue()
				yy60 := &x.HeaderFooter
				yy60.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorksheet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorksheet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "SheetPr":
			if r.TryDecodeAsNil() {
				x.SheetPr = xlsxSheetPr{}
			} else {
				x.SheetPr.CodecDecodeSelf(d)
			}
		case "Dimension":
			if r.TryDecodeAsNil() {
				x.Dimension = xlsxDimension{}
			} else {
				x.Dimension.CodecDecodeSelf(d)
			}
		case "SheetViews":
			if r.TryDecodeAsNil() {
				x.SheetViews = xlsxSheetViews{}
			} else {
				x.SheetViews.CodecDecodeSelf(d)
			}
		case "SheetFormatPr":
			if r.TryDecodeAsNil() {
				x.SheetFormatPr = xlsxSheetFormatPr{}
			} else {
				x.SheetFormatPr.CodecDecodeSelf(d)
			}
		case "Cols":
			if r.TryDecodeAsNil() {
				if true && x.Cols != nil {
					x.Cols = nil
				}
			} else {
				if x.Cols == nil {
					x.Cols = new(xlsxCols)
				}

				x.Cols.CodecDecodeSelf(d)
			}
		case "SheetData":
			if r.TryDecodeAsNil() {
				x.SheetData = xlsxSheetData{}
			} else {
				x.SheetData.CodecDecodeSelf(d)
			}
		case "AutoFilter":
			if r.TryDecodeAsNil() {
				if true && x.AutoFilter != nil {
					x.AutoFilter = nil
				}
			} else {
				if x.AutoFilter == nil {
					x.AutoFilter = new(xlsxAutoFilter)
				}

				x.AutoFilter.CodecDecodeSelf(d)
			}
		case "MergeCells":
			if r.TryDecodeAsNil() {
				if true && x.MergeCells != nil {
					x.MergeCells = nil
				}
			} else {
				if x.MergeCells == nil {
					x.MergeCells = new(xlsxMergeCells)
				}

				x.MergeCells.CodecDecodeSelf(d)
			}
		case "PrintOptions":
			if r.TryDecodeAsNil() {
				x.PrintOptions = xlsxPrintOptions{}
			} else {
				x.PrintOptions.CodecDecodeSelf(d)
			}
		case "PageMargins":
			if r.TryDecodeAsNil() {
				x.PageMargins = xlsxPageMargins{}
			} else {
				x.PageMargins.CodecDecodeSelf(d)
			}
		case "PageSetUp":
			if r.TryDecodeAsNil() {
				x.PageSetUp = xlsxPageSetUp{}
			} else {
				x.PageSetUp.CodecDecodeSelf(d)
			}
		case "HeaderFooter":
			if r.TryDecodeAsNil() {
				x.HeaderFooter = xlsxHeaderFooter{}
			} else {
				x.HeaderFooter.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorksheet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj18 int
	var yyb18 bool
	var yyhl18 bool = l >= 0
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt20 := z.Extension(z.I2Rtid(x.XMLName)); yyxt20 != nil {
			z.DecExtension(x.XMLName, yyxt20)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetPr = xlsxSheetPr{}
	} else {
		x.SheetPr.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Dimension = xlsxDimension{}
	} else {
		x.Dimension.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetViews = xlsxSheetViews{}
	} else {
		x.SheetViews.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetFormatPr = xlsxSheetFormatPr{}
	} else {
		x.SheetFormatPr.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Cols != nil {
			x.Cols = nil
		}
	} else {
		if x.Cols == nil {
			x.Cols = new(xlsxCols)
		}

		x.Cols.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetData = xlsxSheetData{}
	} else {
		x.SheetData.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.AutoFilter != nil {
			x.AutoFilter = nil
		}
	} else {
		if x.AutoFilter == nil {
			x.AutoFilter = new(xlsxAutoFilter)
		}

		x.AutoFilter.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.MergeCells != nil {
			x.MergeCells = nil
		}
	} else {
		if x.MergeCells == nil {
			x.MergeCells = new(xlsxMergeCells)
		}

		x.MergeCells.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PrintOptions = xlsxPrintOptions{}
	} else {
		x.PrintOptions.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PageMargins = xlsxPageMargins{}
	} else {
		x.PageMargins.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PageSetUp = xlsxPageSetUp{}
	} else {
		x.PageSetUp.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.HeaderFooter = xlsxHeaderFooter{}
	} else {
		x.HeaderFooter.CodecDecodeSelf(d)
	}
	for {
		yyj18++
		if yyhl18 {
			yyb18 = yyj18 > l
		} else {
			yyb18 = r.CheckBreak()
		}
		if yyb18 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj18-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxHeaderFooter) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.DifferentFirst))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DifferentFirst`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.DifferentFirst))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.DifferentOddEven))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DifferentOddEven`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.DifferentOddEven))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.OddHeader == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxOddHeader(([]xlsxOddHeader)(x.OddHeader), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OddHeader`)
				r.WriteMapElemValue()
				if x.OddHeader == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxOddHeader(([]xlsxOddHeader)(x.OddHeader), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.OddFooter == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxOddFooter(([]xlsxOddFooter)(x.OddFooter), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OddFooter`)
				r.WriteMapElemValue()
				if x.OddFooter == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxOddFooter(([]xlsxOddFooter)(x.OddFooter), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxHeaderFooter) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxHeaderFooter) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "DifferentFirst":
			if r.TryDecodeAsNil() {
				x.DifferentFirst = false
			} else {
				x.DifferentFirst = (bool)(r.DecodeBool())
			}
		case "DifferentOddEven":
			if r.TryDecodeAsNil() {
				x.DifferentOddEven = false
			} else {
				x.DifferentOddEven = (bool)(r.DecodeBool())
			}
		case "OddHeader":
			if r.TryDecodeAsNil() {
				x.OddHeader = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxOddHeader((*[]xlsxOddHeader)(&x.OddHeader), d)
				}
			}
		case "OddFooter":
			if r.TryDecodeAsNil() {
				x.OddFooter = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxOddFooter((*[]xlsxOddFooter)(&x.OddFooter), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxHeaderFooter) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DifferentFirst = false
	} else {
		x.DifferentFirst = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DifferentOddEven = false
	} else {
		x.DifferentOddEven = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OddHeader = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxOddHeader((*[]xlsxOddHeader)(&x.OddHeader), d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OddFooter = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxOddFooter((*[]xlsxOddFooter)(&x.OddFooter), d)
		}
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxOddHeader) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Content))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Content`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Content))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxOddHeader) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxOddHeader) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Content":
			if r.TryDecodeAsNil() {
				x.Content = ""
			} else {
				x.Content = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxOddHeader) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Content = ""
	} else {
		x.Content = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxOddFooter) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Content))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Content`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Content))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxOddFooter) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxOddFooter) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Content":
			if r.TryDecodeAsNil() {
				x.Content = ""
			} else {
				x.Content = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxOddFooter) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Content = ""
	} else {
		x.Content = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxPageSetUp) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(15)
			} else {
				r.WriteMapStart(15)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PaperSize))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PaperSize`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PaperSize))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Scale))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Scale`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Scale))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FirstPageNumber))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FirstPageNumber`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FirstPageNumber))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FitToWidth))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FitToWidth`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FitToWidth))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FitToHeight))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FitToHeight`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FitToHeight))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PageOrder))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PageOrder`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PageOrder))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Orientation))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Orientation`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Orientation))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.UsePrinterDefaults))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `UsePrinterDefaults`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.UsePrinterDefaults))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.BlackAndWhite))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BlackAndWhite`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.BlackAndWhite))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Draft))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Draft`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Draft))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.CellComments))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CellComments`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.CellComments))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.UseFirstPageNumber))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `UseFirstPageNumber`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.UseFirstPageNumber))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat32(float32(x.HorizontalDPI))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `HorizontalDPI`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat32(float32(x.HorizontalDPI))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat32(float32(x.VerticalDPI))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `VerticalDPI`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat32(float32(x.VerticalDPI))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Copies))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Copies`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Copies))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxPageSetUp) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxPageSetUp) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "PaperSize":
			if r.TryDecodeAsNil() {
				x.PaperSize = ""
			} else {
				x.PaperSize = (string)(r.DecodeString())
			}
		case "Scale":
			if r.TryDecodeAsNil() {
				x.Scale = 0
			} else {
				x.Scale = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FirstPageNumber":
			if r.TryDecodeAsNil() {
				x.FirstPageNumber = 0
			} else {
				x.FirstPageNumber = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FitToWidth":
			if r.TryDecodeAsNil() {
				x.FitToWidth = 0
			} else {
				x.FitToWidth = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FitToHeight":
			if r.TryDecodeAsNil() {
				x.FitToHeight = 0
			} else {
				x.FitToHeight = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "PageOrder":
			if r.TryDecodeAsNil() {
				x.PageOrder = ""
			} else {
				x.PageOrder = (string)(r.DecodeString())
			}
		case "Orientation":
			if r.TryDecodeAsNil() {
				x.Orientation = ""
			} else {
				x.Orientation = (string)(r.DecodeString())
			}
		case "UsePrinterDefaults":
			if r.TryDecodeAsNil() {
				x.UsePrinterDefaults = false
			} else {
				x.UsePrinterDefaults = (bool)(r.DecodeBool())
			}
		case "BlackAndWhite":
			if r.TryDecodeAsNil() {
				x.BlackAndWhite = false
			} else {
				x.BlackAndWhite = (bool)(r.DecodeBool())
			}
		case "Draft":
			if r.TryDecodeAsNil() {
				x.Draft = false
			} else {
				x.Draft = (bool)(r.DecodeBool())
			}
		case "CellComments":
			if r.TryDecodeAsNil() {
				x.CellComments = ""
			} else {
				x.CellComments = (string)(r.DecodeString())
			}
		case "UseFirstPageNumber":
			if r.TryDecodeAsNil() {
				x.UseFirstPageNumber = false
			} else {
				x.UseFirstPageNumber = (bool)(r.DecodeBool())
			}
		case "HorizontalDPI":
			if r.TryDecodeAsNil() {
				x.HorizontalDPI = 0
			} else {
				x.HorizontalDPI = (float32)(r.DecodeFloat32As64())
			}
		case "VerticalDPI":
			if r.TryDecodeAsNil() {
				x.VerticalDPI = 0
			} else {
				x.VerticalDPI = (float32)(r.DecodeFloat32As64())
			}
		case "Copies":
			if r.TryDecodeAsNil() {
				x.Copies = 0
			} else {
				x.Copies = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxPageSetUp) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj19 int
	var yyb19 bool
	var yyhl19 bool = l >= 0
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PaperSize = ""
	} else {
		x.PaperSize = (string)(r.DecodeString())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Scale = 0
	} else {
		x.Scale = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FirstPageNumber = 0
	} else {
		x.FirstPageNumber = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FitToWidth = 0
	} else {
		x.FitToWidth = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FitToHeight = 0
	} else {
		x.FitToHeight = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PageOrder = ""
	} else {
		x.PageOrder = (string)(r.DecodeString())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Orientation = ""
	} else {
		x.Orientation = (string)(r.DecodeString())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.UsePrinterDefaults = false
	} else {
		x.UsePrinterDefaults = (bool)(r.DecodeBool())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BlackAndWhite = false
	} else {
		x.BlackAndWhite = (bool)(r.DecodeBool())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Draft = false
	} else {
		x.Draft = (bool)(r.DecodeBool())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CellComments = ""
	} else {
		x.CellComments = (string)(r.DecodeString())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.UseFirstPageNumber = false
	} else {
		x.UseFirstPageNumber = (bool)(r.DecodeBool())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.HorizontalDPI = 0
	} else {
		x.HorizontalDPI = (float32)(r.DecodeFloat32As64())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.VerticalDPI = 0
	} else {
		x.VerticalDPI = (float32)(r.DecodeFloat32As64())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = r.CheckBreak()
	}
	if yyb19 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Copies = 0
	} else {
		x.Copies = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	for {
		yyj19++
		if yyhl19 {
			yyb19 = yyj19 > l
		} else {
			yyb19 = r.CheckBreak()
		}
		if yyb19 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj19-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxPrintOptions) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(5)
			} else {
				r.WriteMapStart(5)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Headings))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Headings`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Headings))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.GridLines))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `GridLines`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.GridLines))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.GridLinesSet))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `GridLinesSet`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.GridLinesSet))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.HorizontalCentered))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `HorizontalCentered`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.HorizontalCentered))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.VerticalCentered))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `VerticalCentered`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.VerticalCentered))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxPrintOptions) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxPrintOptions) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Headings":
			if r.TryDecodeAsNil() {
				x.Headings = false
			} else {
				x.Headings = (bool)(r.DecodeBool())
			}
		case "GridLines":
			if r.TryDecodeAsNil() {
				x.GridLines = false
			} else {
				x.GridLines = (bool)(r.DecodeBool())
			}
		case "GridLinesSet":
			if r.TryDecodeAsNil() {
				x.GridLinesSet = false
			} else {
				x.GridLinesSet = (bool)(r.DecodeBool())
			}
		case "HorizontalCentered":
			if r.TryDecodeAsNil() {
				x.HorizontalCentered = false
			} else {
				x.HorizontalCentered = (bool)(r.DecodeBool())
			}
		case "VerticalCentered":
			if r.TryDecodeAsNil() {
				x.VerticalCentered = false
			} else {
				x.VerticalCentered = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxPrintOptions) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Headings = false
	} else {
		x.Headings = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.GridLines = false
	} else {
		x.GridLines = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.GridLinesSet = false
	} else {
		x.GridLinesSet = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.HorizontalCentered = false
	} else {
		x.HorizontalCentered = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.VerticalCentered = false
	} else {
		x.VerticalCentered = (bool)(r.DecodeBool())
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxPageMargins) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(6)
			} else {
				r.WriteMapStart(6)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Left))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Left`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Left))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Right))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Right`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Right))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Top))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Top`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Top))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Bottom))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Bottom`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Bottom))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Header))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Header`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Header))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Footer))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Footer`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Footer))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxPageMargins) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxPageMargins) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Left":
			if r.TryDecodeAsNil() {
				x.Left = 0
			} else {
				x.Left = (float64)(r.DecodeFloat64())
			}
		case "Right":
			if r.TryDecodeAsNil() {
				x.Right = 0
			} else {
				x.Right = (float64)(r.DecodeFloat64())
			}
		case "Top":
			if r.TryDecodeAsNil() {
				x.Top = 0
			} else {
				x.Top = (float64)(r.DecodeFloat64())
			}
		case "Bottom":
			if r.TryDecodeAsNil() {
				x.Bottom = 0
			} else {
				x.Bottom = (float64)(r.DecodeFloat64())
			}
		case "Header":
			if r.TryDecodeAsNil() {
				x.Header = 0
			} else {
				x.Header = (float64)(r.DecodeFloat64())
			}
		case "Footer":
			if r.TryDecodeAsNil() {
				x.Footer = 0
			} else {
				x.Footer = (float64)(r.DecodeFloat64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxPageMargins) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Left = 0
	} else {
		x.Left = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Right = 0
	} else {
		x.Right = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Top = 0
	} else {
		x.Top = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Bottom = 0
	} else {
		x.Bottom = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Header = 0
	} else {
		x.Header = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Footer = 0
	} else {
		x.Footer = (float64)(r.DecodeFloat64())
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheetFormatPr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultColWidth))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefaultColWidth`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultColWidth))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultRowHeight))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefaultRowHeight`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultRowHeight))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelCol))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevelCol`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelCol))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelRow))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevelRow`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelRow))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheetFormatPr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheetFormatPr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "DefaultColWidth":
			if r.TryDecodeAsNil() {
				x.DefaultColWidth = 0
			} else {
				x.DefaultColWidth = (float64)(r.DecodeFloat64())
			}
		case "DefaultRowHeight":
			if r.TryDecodeAsNil() {
				x.DefaultRowHeight = 0
			} else {
				x.DefaultRowHeight = (float64)(r.DecodeFloat64())
			}
		case "OutlineLevelCol":
			if r.TryDecodeAsNil() {
				x.OutlineLevelCol = 0
			} else {
				x.OutlineLevelCol = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "OutlineLevelRow":
			if r.TryDecodeAsNil() {
				x.OutlineLevelRow = 0
			} else {
				x.OutlineLevelRow = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheetFormatPr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefaultColWidth = 0
	} else {
		x.DefaultColWidth = (float64)(r.DecodeFloat64())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefaultRowHeight = 0
	} else {
		x.DefaultRowHeight = (float64)(r.DecodeFloat64())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevelCol = 0
	} else {
		x.OutlineLevelCol = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevelRow = 0
	} else {
		x.OutlineLevelRow = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheetViews) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.SheetView == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSheetView(([]xlsxSheetView)(x.SheetView), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetView`)
				r.WriteMapElemValue()
				if x.SheetView == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSheetView(([]xlsxSheetView)(x.SheetView), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheetViews) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheetViews) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "SheetView":
			if r.TryDecodeAsNil() {
				x.SheetView = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxSheetView((*[]xlsxSheetView)(&x.SheetView), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheetViews) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetView = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxSheetView((*[]xlsxSheetView)(&x.SheetView), d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheetView) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(18)
			} else {
				r.WriteMapStart(18)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.WindowProtection))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WindowProtection`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.WindowProtection))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowFormulas))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowFormulas`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowFormulas))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowGridLines))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowGridLines`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowGridLines))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowRowColHeaders))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowRowColHeaders`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowRowColHeaders))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowZeros))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowZeros`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowZeros))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.RightToLeft))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `RightToLeft`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.RightToLeft))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.TabSelected))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TabSelected`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.TabSelected))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowOutlineSymbols))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowOutlineSymbols`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowOutlineSymbols))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.DefaultGridColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefaultGridColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.DefaultGridColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.View))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `View`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.View))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TopLeftCell`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.ColorId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ColorId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.ColorId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.ZoomScale))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ZoomScale`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.ZoomScale))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.ZoomScaleNormal))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ZoomScaleNormal`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.ZoomScaleNormal))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.ZoomScalePageLayoutView))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ZoomScalePageLayoutView`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.ZoomScalePageLayoutView))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.WorkbookViewId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WorkbookViewId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.WorkbookViewId))
				}
			}
			var yyn51 bool
			if x.Pane == nil {
				yyn51 = true
				goto LABEL51
			}
		LABEL51:
			if yyr2 || yy2arr2 {
				if yyn51 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Pane == nil {
						r.EncodeNil()
					} else {
						x.Pane.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Pane`)
				r.WriteMapElemValue()
				if yyn51 {
					r.EncodeNil()
				} else {
					if x.Pane == nil {
						r.EncodeNil()
					} else {
						x.Pane.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Selection == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSelection(([]xlsxSelection)(x.Selection), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Selection`)
				r.WriteMapElemValue()
				if x.Selection == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSelection(([]xlsxSelection)(x.Selection), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheetView) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheetView) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "WindowProtection":
			if r.TryDecodeAsNil() {
				x.WindowProtection = false
			} else {
				x.WindowProtection = (bool)(r.DecodeBool())
			}
		case "ShowFormulas":
			if r.TryDecodeAsNil() {
				x.ShowFormulas = false
			} else {
				x.ShowFormulas = (bool)(r.DecodeBool())
			}
		case "ShowGridLines":
			if r.TryDecodeAsNil() {
				x.ShowGridLines = false
			} else {
				x.ShowGridLines = (bool)(r.DecodeBool())
			}
		case "ShowRowColHeaders":
			if r.TryDecodeAsNil() {
				x.ShowRowColHeaders = false
			} else {
				x.ShowRowColHeaders = (bool)(r.DecodeBool())
			}
		case "ShowZeros":
			if r.TryDecodeAsNil() {
				x.ShowZeros = false
			} else {
				x.ShowZeros = (bool)(r.DecodeBool())
			}
		case "RightToLeft":
			if r.TryDecodeAsNil() {
				x.RightToLeft = false
			} else {
				x.RightToLeft = (bool)(r.DecodeBool())
			}
		case "TabSelected":
			if r.TryDecodeAsNil() {
				x.TabSelected = false
			} else {
				x.TabSelected = (bool)(r.DecodeBool())
			}
		case "ShowOutlineSymbols":
			if r.TryDecodeAsNil() {
				x.ShowOutlineSymbols = false
			} else {
				x.ShowOutlineSymbols = (bool)(r.DecodeBool())
			}
		case "DefaultGridColor":
			if r.TryDecodeAsNil() {
				x.DefaultGridColor = false
			} else {
				x.DefaultGridColor = (bool)(r.DecodeBool())
			}
		case "View":
			if r.TryDecodeAsNil() {
				x.View = ""
			} else {
				x.View = (string)(r.DecodeString())
			}
		case "TopLeftCell":
			if r.TryDecodeAsNil() {
				x.TopLeftCell = ""
			} else {
				x.TopLeftCell = (string)(r.DecodeString())
			}
		case "ColorId":
			if r.TryDecodeAsNil() {
				x.ColorId = 0
			} else {
				x.ColorId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "ZoomScale":
			if r.TryDecodeAsNil() {
				x.ZoomScale = 0
			} else {
				x.ZoomScale = (float64)(r.DecodeFloat64())
			}
		case "ZoomScaleNormal":
			if r.TryDecodeAsNil() {
				x.ZoomScaleNormal = 0
			} else {
				x.ZoomScaleNormal = (float64)(r.DecodeFloat64())
			}
		case "ZoomScalePageLayoutView":
			if r.TryDecodeAsNil() {
				x.ZoomScalePageLayoutView = 0
			} else {
				x.ZoomScalePageLayoutView = (float64)(r.DecodeFloat64())
			}
		case "WorkbookViewId":
			if r.TryDecodeAsNil() {
				x.WorkbookViewId = 0
			} else {
				x.WorkbookViewId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Pane":
			if r.TryDecodeAsNil() {
				if true && x.Pane != nil {
					x.Pane = nil
				}
			} else {
				if x.Pane == nil {
					x.Pane = new(xlsxPane)
				}

				x.Pane.CodecDecodeSelf(d)
			}
		case "Selection":
			if r.TryDecodeAsNil() {
				x.Selection = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxSelection((*[]xlsxSelection)(&x.Selection), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheetView) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj23 int
	var yyb23 bool
	var yyhl23 bool = l >= 0
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WindowProtection = false
	} else {
		x.WindowProtection = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowFormulas = false
	} else {
		x.ShowFormulas = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowGridLines = false
	} else {
		x.ShowGridLines = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowRowColHeaders = false
	} else {
		x.ShowRowColHeaders = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowZeros = false
	} else {
		x.ShowZeros = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.RightToLeft = false
	} else {
		x.RightToLeft = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TabSelected = false
	} else {
		x.TabSelected = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowOutlineSymbols = false
	} else {
		x.ShowOutlineSymbols = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefaultGridColor = false
	} else {
		x.DefaultGridColor = (bool)(r.DecodeBool())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.View = ""
	} else {
		x.View = (string)(r.DecodeString())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TopLeftCell = ""
	} else {
		x.TopLeftCell = (string)(r.DecodeString())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ColorId = 0
	} else {
		x.ColorId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ZoomScale = 0
	} else {
		x.ZoomScale = (float64)(r.DecodeFloat64())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ZoomScaleNormal = 0
	} else {
		x.ZoomScaleNormal = (float64)(r.DecodeFloat64())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ZoomScalePageLayoutView = 0
	} else {
		x.ZoomScalePageLayoutView = (float64)(r.DecodeFloat64())
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WorkbookViewId = 0
	} else {
		x.WorkbookViewId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Pane != nil {
			x.Pane = nil
		}
	} else {
		if x.Pane == nil {
			x.Pane = new(xlsxPane)
		}

		x.Pane.CodecDecodeSelf(d)
	}
	yyj23++
	if yyhl23 {
		yyb23 = yyj23 > l
	} else {
		yyb23 = r.CheckBreak()
	}
	if yyb23 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Selection = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxSelection((*[]xlsxSelection)(&x.Selection), d)
		}
	}
	for {
		yyj23++
		if yyhl23 {
			yyb23 = yyj23 > l
		} else {
			yyb23 = r.CheckBreak()
		}
		if yyb23 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj23-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSelection) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Pane))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Pane`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Pane))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ActiveCell))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ActiveCell`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ActiveCell))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.ActiveCellId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ActiveCellId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.ActiveCellId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.SQRef))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SQRef`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.SQRef))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSelection) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSelection) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Pane":
			if r.TryDecodeAsNil() {
				x.Pane = ""
			} else {
				x.Pane = (string)(r.DecodeString())
			}
		case "ActiveCell":
			if r.TryDecodeAsNil() {
				x.ActiveCell = ""
			} else {
				x.ActiveCell = (string)(r.DecodeString())
			}
		case "ActiveCellId":
			if r.TryDecodeAsNil() {
				x.ActiveCellId = 0
			} else {
				x.ActiveCellId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "SQRef":
			if r.TryDecodeAsNil() {
				x.SQRef = ""
			} else {
				x.SQRef = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSelection) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Pane = ""
	} else {
		x.Pane = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ActiveCell = ""
	} else {
		x.ActiveCell = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ActiveCellId = 0
	} else {
		x.ActiveCellId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SQRef = ""
	} else {
		x.SQRef = (string)(r.DecodeString())
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxPane) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(5)
			} else {
				r.WriteMapStart(5)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.XSplit))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XSplit`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.XSplit))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.YSplit))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `YSplit`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.YSplit))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TopLeftCell`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ActivePane))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ActivePane`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ActivePane))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.State))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `State`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.State))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxPane) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxPane) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XSplit":
			if r.TryDecodeAsNil() {
				x.XSplit = 0
			} else {
				x.XSplit = (float64)(r.DecodeFloat64())
			}
		case "YSplit":
			if r.TryDecodeAsNil() {
				x.YSplit = 0
			} else {
				x.YSplit = (float64)(r.DecodeFloat64())
			}
		case "TopLeftCell":
			if r.TryDecodeAsNil() {
				x.TopLeftCell = ""
			} else {
				x.TopLeftCell = (string)(r.DecodeString())
			}
		case "ActivePane":
			if r.TryDecodeAsNil() {
				x.ActivePane = ""
			} else {
				x.ActivePane = (string)(r.DecodeString())
			}
		case "State":
			if r.TryDecodeAsNil() {
				x.State = ""
			} else {
				x.State = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxPane) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XSplit = 0
	} else {
		x.XSplit = (float64)(r.DecodeFloat64())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.YSplit = 0
	} else {
		x.YSplit = (float64)(r.DecodeFloat64())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TopLeftCell = ""
	} else {
		x.TopLeftCell = (string)(r.DecodeString())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ActivePane = ""
	} else {
		x.ActivePane = (string)(r.DecodeString())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.State = ""
	} else {
		x.State = (string)(r.DecodeString())
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheetPr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.FilterMode))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FilterMode`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.FilterMode))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.PageSetUpPr == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxPageSetUpPr(([]xlsxPageSetUpPr)(x.PageSetUpPr), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PageSetUpPr`)
				r.WriteMapElemValue()
				if x.PageSetUpPr == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxPageSetUpPr(([]xlsxPageSetUpPr)(x.PageSetUpPr), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheetPr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheetPr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "FilterMode":
			if r.TryDecodeAsNil() {
				x.FilterMode = false
			} else {
				x.FilterMode = (bool)(r.DecodeBool())
			}
		case "PageSetUpPr":
			if r.TryDecodeAsNil() {
				x.PageSetUpPr = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxPageSetUpPr((*[]xlsxPageSetUpPr)(&x.PageSetUpPr), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheetPr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FilterMode = false
	} else {
		x.FilterMode = (bool)(r.DecodeBool())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PageSetUpPr = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxPageSetUpPr((*[]xlsxPageSetUpPr)(&x.PageSetUpPr), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxPageSetUpPr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.FitToPage))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FitToPage`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.FitToPage))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxPageSetUpPr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxPageSetUpPr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "FitToPage":
			if r.TryDecodeAsNil() {
				x.FitToPage = false
			} else {
				x.FitToPage = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxPageSetUpPr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FitToPage = false
	} else {
		x.FitToPage = (bool)(r.DecodeBool())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCols) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Col == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxCol(([]xlsxCol)(x.Col), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Col`)
				r.WriteMapElemValue()
				if x.Col == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxCol(([]xlsxCol)(x.Col), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCols) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCols) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Col":
			if r.TryDecodeAsNil() {
				x.Col = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxCol((*[]xlsxCol)(&x.Col), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCols) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Col = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxCol((*[]xlsxCol)(&x.Col), d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCol) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(8)
			} else {
				r.WriteMapStart(8)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Collapsed))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Collapsed`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Collapsed))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Max))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Max`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Max))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Min))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Min`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Min))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Style))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Style`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Style))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Width))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Width`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Width))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.CustomWidth))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CustomWidth`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.CustomWidth))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevel`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCol) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCol) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Collapsed":
			if r.TryDecodeAsNil() {
				x.Collapsed = false
			} else {
				x.Collapsed = (bool)(r.DecodeBool())
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "Max":
			if r.TryDecodeAsNil() {
				x.Max = 0
			} else {
				x.Max = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Min":
			if r.TryDecodeAsNil() {
				x.Min = 0
			} else {
				x.Min = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Style":
			if r.TryDecodeAsNil() {
				x.Style = 0
			} else {
				x.Style = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Width":
			if r.TryDecodeAsNil() {
				x.Width = 0
			} else {
				x.Width = (float64)(r.DecodeFloat64())
			}
		case "CustomWidth":
			if r.TryDecodeAsNil() {
				x.CustomWidth = false
			} else {
				x.CustomWidth = (bool)(r.DecodeBool())
			}
		case "OutlineLevel":
			if r.TryDecodeAsNil() {
				x.OutlineLevel = 0
			} else {
				x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCol) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Collapsed = false
	} else {
		x.Collapsed = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Max = 0
	} else {
		x.Max = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Min = 0
	} else {
		x.Min = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Style = 0
	} else {
		x.Style = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Width = 0
	} else {
		x.Width = (float64)(r.DecodeFloat64())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CustomWidth = false
	} else {
		x.CustomWidth = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevel = 0
	} else {
		x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = r.CheckBreak()
		}
		if yyb12 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxDimension) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Ref`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxDimension) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxDimension) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Ref":
			if r.TryDecodeAsNil() {
				x.Ref = ""
			} else {
				x.Ref = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxDimension) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ref = ""
	} else {
		x.Ref = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheetData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Row == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxRow(([]xlsxRow)(x.Row), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Row`)
				r.WriteMapElemValue()
				if x.Row == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxRow(([]xlsxRow)(x.Row), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheetData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheetData) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Row":
			if r.TryDecodeAsNil() {
				x.Row = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxRow((*[]xlsxRow)(&x.Row), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheetData) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt10 := z.Extension(z.I2Rtid(x.XMLName)); yyxt10 != nil {
			z.DecExtension(x.XMLName, yyxt10)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Row = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxRow((*[]xlsxRow)(&x.Row), d)
		}
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxRow) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(7)
			} else {
				r.WriteMapStart(7)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.R))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `R`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.R))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Spans))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Spans`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Spans))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.C == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxC(([]xlsxC)(x.C), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `C`)
				r.WriteMapElemValue()
				if x.C == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxC(([]xlsxC)(x.C), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ht))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Ht`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ht))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.CustomHeight))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CustomHeight`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.CustomHeight))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevel`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxRow) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxRow) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "R":
			if r.TryDecodeAsNil() {
				x.R = 0
			} else {
				x.R = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Spans":
			if r.TryDecodeAsNil() {
				x.Spans = ""
			} else {
				x.Spans = (string)(r.DecodeString())
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "C":
			if r.TryDecodeAsNil() {
				x.C = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxC((*[]xlsxC)(&x.C), d)
				}
			}
		case "Ht":
			if r.TryDecodeAsNil() {
				x.Ht = ""
			} else {
				x.Ht = (string)(r.DecodeString())
			}
		case "CustomHeight":
			if r.TryDecodeAsNil() {
				x.CustomHeight = false
			} else {
				x.CustomHeight = (bool)(r.DecodeBool())
			}
		case "OutlineLevel":
			if r.TryDecodeAsNil() {
				x.OutlineLevel = 0
			} else {
				x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxRow) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.R = 0
	} else {
		x.R = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Spans = ""
	} else {
		x.Spans = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.C = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxC((*[]xlsxC)(&x.C), d)
		}
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ht = ""
	} else {
		x.Ht = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CustomHeight = false
	} else {
		x.CustomHeight = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevel = 0
	} else {
		x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = r.CheckBreak()
		}
		if yyb12 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxAutoFilter) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Ref`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxAutoFilter) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxAutoFilter) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Ref":
			if r.TryDecodeAsNil() {
				x.Ref = ""
			} else {
				x.Ref = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxAutoFilter) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ref = ""
	} else {
		x.Ref = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxMergeCell) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Ref`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxMergeCell) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxMergeCell) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Ref":
			if r.TryDecodeAsNil() {
				x.Ref = ""
			} else {
				x.Ref = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxMergeCell) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ref = ""
	} else {
		x.Ref = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxMergeCells) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Cells == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxMergeCell(([]xlsxMergeCell)(x.Cells), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Cells`)
				r.WriteMapElemValue()
				if x.Cells == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxMergeCell(([]xlsxMergeCell)(x.Cells), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxMergeCells) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxMergeCells) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Cells":
			if r.TryDecodeAsNil() {
				x.Cells = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxMergeCell((*[]xlsxMergeCell)(&x.Cells), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxMergeCells) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt11 := z.Extension(z.I2Rtid(x.XMLName)); yyxt11 != nil {
			z.DecExtension(x.XMLName, yyxt11)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Cells = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxMergeCell((*[]xlsxMergeCell)(&x.Cells), d)
		}
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxC) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(6)
			} else {
				r.WriteMapStart(6)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.R))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `R`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.R))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.S))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `S`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.S))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `T`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			}
			var yyn12 bool
			if x.F == nil {
				yyn12 = true
				goto LABEL12
			}
		LABEL12:
			if yyr2 || yy2arr2 {
				if yyn12 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.F == nil {
						r.EncodeNil()
					} else {
						x.F.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `F`)
				r.WriteMapElemValue()
				if yyn12 {
					r.EncodeNil()
				} else {
					if x.F == nil {
						r.EncodeNil()
					} else {
						x.F.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.V))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `V`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.V))
				}
			}
			var yyn18 bool
			if x.Is == nil {
				yyn18 = true
				goto LABEL18
			}
		LABEL18:
			if yyr2 || yy2arr2 {
				if yyn18 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Is == nil {
						r.EncodeNil()
					} else {
						x.Is.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Is`)
				r.WriteMapElemValue()
				if yyn18 {
					r.EncodeNil()
				} else {
					if x.Is == nil {
						r.EncodeNil()
					} else {
						x.Is.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxC) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxC) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "R":
			if r.TryDecodeAsNil() {
				x.R = ""
			} else {
				x.R = (string)(r.DecodeString())
			}
		case "S":
			if r.TryDecodeAsNil() {
				x.S = 0
			} else {
				x.S = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "T":
			if r.TryDecodeAsNil() {
				x.T = ""
			} else {
				x.T = (string)(r.DecodeString())
			}
		case "F":
			if r.TryDecodeAsNil() {
				if true && x.F != nil {
					x.F = nil
				}
			} else {
				if x.F == nil {
					x.F = new(xlsxF)
				}

				x.F.CodecDecodeSelf(d)
			}
		case "V":
			if r.TryDecodeAsNil() {
				x.V = ""
			} else {
				x.V = (string)(r.DecodeString())
			}
		case "Is":
			if r.TryDecodeAsNil() {
				if true && x.Is != nil {
					x.Is = nil
				}
			} else {
				if x.Is == nil {
					x.Is = new(xlsxSI)
				}

				x.Is.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxC) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.R = ""
	} else {
		x.R = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = 0
	} else {
		x.S = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.T = ""
	} else {
		x.T = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.F != nil {
			x.F = nil
		}
	} else {
		if x.F == nil {
			x.F = new(xlsxF)
		}

		x.F.CodecDecodeSelf(d)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.V = ""
	} else {
		x.V = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Is != nil {
			x.Is = nil
		}
	} else {
		if x.Is == nil {
			x.Is = new(xlsxSI)
		}

		x.Is.CodecDecodeSelf(d)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxF) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Content))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Content`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Content))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `T`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Ref`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Ref))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Si))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Si`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Si))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxF) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxF) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Content":
			if r.TryDecodeAsNil() {
				x.Content = ""
			} else {
				x.Content = (string)(r.DecodeString())
			}
		case "T":
			if r.TryDecodeAsNil() {
				x.T = ""
			} else {
				x.T = (string)(r.DecodeString())
			}
		case "Ref":
			if r.TryDecodeAsNil() {
				x.Ref = ""
			} else {
				x.Ref = (string)(r.DecodeString())
			}
		case "Si":
			if r.TryDecodeAsNil() {
				x.Si = 0
			} else {
				x.Si = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxF) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Content = ""
	} else {
		x.Content = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.T = ""
	} else {
		x.T = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ref = ""
	} else {
		x.Ref = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Si = 0
	} else {
		x.Si = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *theme) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *theme) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *theme) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *theme) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Style) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(9)
			} else {
				r.WriteMapStart(9)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.Border
				yy4.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Border`)
				r.WriteMapElemValue()
				yy6 := &x.Border
				yy6.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy9 := &x.Fill
				yy9.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Fill`)
				r.WriteMapElemValue()
				yy11 := &x.Fill
				yy11.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy14 := &x.Font
				yy14.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Font`)
				r.WriteMapElemValue()
				yy16 := &x.Font
				yy16.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyBorder))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyBorder`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyBorder))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFill))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyFill`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFill))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFont))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyFont`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFont))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyAlignment))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyAlignment`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyAlignment))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy31 := &x.Alignment
				yy31.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Alignment`)
				r.WriteMapElemValue()
				yy33 := &x.Alignment
				yy33.CodecEncodeSelf(e)
			}
			var yyn35 bool
			if x.NamedStyleIndex == nil {
				yyn35 = true
				goto LABEL35
			}
		LABEL35:
			if yyr2 || yy2arr2 {
				if yyn35 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.NamedStyleIndex == nil {
						r.EncodeNil()
					} else {
						yy36 := *x.NamedStyleIndex
						if false {
						} else {
							r.EncodeInt(int64(yy36))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `NamedStyleIndex`)
				r.WriteMapElemValue()
				if yyn35 {
					r.EncodeNil()
				} else {
					if x.NamedStyleIndex == nil {
						r.EncodeNil()
					} else {
						yy38 := *x.NamedStyleIndex
						if false {
						} else {
							r.EncodeInt(int64(yy38))
						}
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Style) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Style) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Border":
			if r.TryDecodeAsNil() {
				x.Border = Border{}
			} else {
				x.Border.CodecDecodeSelf(d)
			}
		case "Fill":
			if r.TryDecodeAsNil() {
				x.Fill = Fill{}
			} else {
				x.Fill.CodecDecodeSelf(d)
			}
		case "Font":
			if r.TryDecodeAsNil() {
				x.Font = Font{}
			} else {
				x.Font.CodecDecodeSelf(d)
			}
		case "ApplyBorder":
			if r.TryDecodeAsNil() {
				x.ApplyBorder = false
			} else {
				x.ApplyBorder = (bool)(r.DecodeBool())
			}
		case "ApplyFill":
			if r.TryDecodeAsNil() {
				x.ApplyFill = false
			} else {
				x.ApplyFill = (bool)(r.DecodeBool())
			}
		case "ApplyFont":
			if r.TryDecodeAsNil() {
				x.ApplyFont = false
			} else {
				x.ApplyFont = (bool)(r.DecodeBool())
			}
		case "ApplyAlignment":
			if r.TryDecodeAsNil() {
				x.ApplyAlignment = false
			} else {
				x.ApplyAlignment = (bool)(r.DecodeBool())
			}
		case "Alignment":
			if r.TryDecodeAsNil() {
				x.Alignment = Alignment{}
			} else {
				x.Alignment.CodecDecodeSelf(d)
			}
		case "NamedStyleIndex":
			if r.TryDecodeAsNil() {
				if true && x.NamedStyleIndex != nil {
					x.NamedStyleIndex = nil
				}
			} else {
				if x.NamedStyleIndex == nil {
					x.NamedStyleIndex = new(int)
				}

				if false {
				} else {
					*x.NamedStyleIndex = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Style) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Border = Border{}
	} else {
		x.Border.CodecDecodeSelf(d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Fill = Fill{}
	} else {
		x.Fill.CodecDecodeSelf(d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Font = Font{}
	} else {
		x.Font.CodecDecodeSelf(d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyBorder = false
	} else {
		x.ApplyBorder = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyFill = false
	} else {
		x.ApplyFill = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyFont = false
	} else {
		x.ApplyFont = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyAlignment = false
	} else {
		x.ApplyAlignment = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Alignment = Alignment{}
	} else {
		x.Alignment.CodecDecodeSelf(d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.NamedStyleIndex != nil {
			x.NamedStyleIndex = nil
		}
	} else {
		if x.NamedStyleIndex == nil {
			x.NamedStyleIndex = new(int)
		}

		if false {
		} else {
			*x.NamedStyleIndex = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
		}
	}
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = r.CheckBreak()
		}
		if yyb14 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Border) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(8)
			} else {
				r.WriteMapStart(8)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Left))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Left`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Left))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LeftColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `LeftColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LeftColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Right))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Right`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Right))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RightColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `RightColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RightColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Top))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Top`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Top))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TopColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Bottom))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Bottom`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Bottom))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.BottomColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BottomColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.BottomColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Border) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Border) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Left":
			if r.TryDecodeAsNil() {
				x.Left = ""
			} else {
				x.Left = (string)(r.DecodeString())
			}
		case "LeftColor":
			if r.TryDecodeAsNil() {
				x.LeftColor = ""
			} else {
				x.LeftColor = (string)(r.DecodeString())
			}
		case "Right":
			if r.TryDecodeAsNil() {
				x.Right = ""
			} else {
				x.Right = (string)(r.DecodeString())
			}
		case "RightColor":
			if r.TryDecodeAsNil() {
				x.RightColor = ""
			} else {
				x.RightColor = (string)(r.DecodeString())
			}
		case "Top":
			if r.TryDecodeAsNil() {
				x.Top = ""
			} else {
				x.Top = (string)(r.DecodeString())
			}
		case "TopColor":
			if r.TryDecodeAsNil() {
				x.TopColor = ""
			} else {
				x.TopColor = (string)(r.DecodeString())
			}
		case "Bottom":
			if r.TryDecodeAsNil() {
				x.Bottom = ""
			} else {
				x.Bottom = (string)(r.DecodeString())
			}
		case "BottomColor":
			if r.TryDecodeAsNil() {
				x.BottomColor = ""
			} else {
				x.BottomColor = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Border) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Left = ""
	} else {
		x.Left = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.LeftColor = ""
	} else {
		x.LeftColor = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Right = ""
	} else {
		x.Right = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.RightColor = ""
	} else {
		x.RightColor = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Top = ""
	} else {
		x.Top = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TopColor = ""
	} else {
		x.TopColor = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Bottom = ""
	} else {
		x.Bottom = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BottomColor = ""
	} else {
		x.BottomColor = (string)(r.DecodeString())
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = r.CheckBreak()
		}
		if yyb12 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Fill) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PatternType))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PatternType`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PatternType))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.BgColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BgColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.BgColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.FgColor))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FgColor`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.FgColor))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Fill) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Fill) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "PatternType":
			if r.TryDecodeAsNil() {
				x.PatternType = ""
			} else {
				x.PatternType = (string)(r.DecodeString())
			}
		case "BgColor":
			if r.TryDecodeAsNil() {
				x.BgColor = ""
			} else {
				x.BgColor = (string)(r.DecodeString())
			}
		case "FgColor":
			if r.TryDecodeAsNil() {
				x.FgColor = ""
			} else {
				x.FgColor = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Fill) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PatternType = ""
	} else {
		x.PatternType = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BgColor = ""
	} else {
		x.BgColor = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FgColor = ""
	} else {
		x.FgColor = (string)(r.DecodeString())
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Font) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(8)
			} else {
				r.WriteMapStart(8)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Size))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Size`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Size))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Family))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Family`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Family))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Charset))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Charset`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Charset))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Color))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Color`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Color))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Bold))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Bold`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Bold))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Italic))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Italic`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Italic))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Underline))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Underline`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Underline))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Font) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Font) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Size":
			if r.TryDecodeAsNil() {
				x.Size = 0
			} else {
				x.Size = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = ""
			} else {
				x.Name = (string)(r.DecodeString())
			}
		case "Family":
			if r.TryDecodeAsNil() {
				x.Family = 0
			} else {
				x.Family = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Charset":
			if r.TryDecodeAsNil() {
				x.Charset = 0
			} else {
				x.Charset = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Color":
			if r.TryDecodeAsNil() {
				x.Color = ""
			} else {
				x.Color = (string)(r.DecodeString())
			}
		case "Bold":
			if r.TryDecodeAsNil() {
				x.Bold = false
			} else {
				x.Bold = (bool)(r.DecodeBool())
			}
		case "Italic":
			if r.TryDecodeAsNil() {
				x.Italic = false
			} else {
				x.Italic = (bool)(r.DecodeBool())
			}
		case "Underline":
			if r.TryDecodeAsNil() {
				x.Underline = false
			} else {
				x.Underline = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Font) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Size = 0
	} else {
		x.Size = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = ""
	} else {
		x.Name = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Family = 0
	} else {
		x.Family = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Charset = 0
	} else {
		x.Charset = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Color = ""
	} else {
		x.Color = (string)(r.DecodeString())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Bold = false
	} else {
		x.Bold = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Italic = false
	} else {
		x.Italic = (bool)(r.DecodeBool())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Underline = false
	} else {
		x.Underline = (bool)(r.DecodeBool())
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = r.CheckBreak()
		}
		if yyb12 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Alignment) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(6)
			} else {
				r.WriteMapStart(6)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Horizontal))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Horizontal`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Horizontal))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Indent))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Indent`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Indent))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShrinkToFit))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShrinkToFit`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShrinkToFit))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.TextRotation))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TextRotation`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.TextRotation))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Vertical))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Vertical`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Vertical))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.WrapText))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WrapText`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.WrapText))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Alignment) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Alignment) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Horizontal":
			if r.TryDecodeAsNil() {
				x.Horizontal = ""
			} else {
				x.Horizontal = (string)(r.DecodeString())
			}
		case "Indent":
			if r.TryDecodeAsNil() {
				x.Indent = 0
			} else {
				x.Indent = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "ShrinkToFit":
			if r.TryDecodeAsNil() {
				x.ShrinkToFit = false
			} else {
				x.ShrinkToFit = (bool)(r.DecodeBool())
			}
		case "TextRotation":
			if r.TryDecodeAsNil() {
				x.TextRotation = 0
			} else {
				x.TextRotation = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Vertical":
			if r.TryDecodeAsNil() {
				x.Vertical = ""
			} else {
				x.Vertical = (string)(r.DecodeString())
			}
		case "WrapText":
			if r.TryDecodeAsNil() {
				x.WrapText = false
			} else {
				x.WrapText = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Alignment) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Horizontal = ""
	} else {
		x.Horizontal = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Indent = 0
	} else {
		x.Indent = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShrinkToFit = false
	} else {
		x.ShrinkToFit = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TextRotation = 0
	} else {
		x.TextRotation = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Vertical = ""
	} else {
		x.Vertical = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WrapText = false
	} else {
		x.WrapText = (bool)(r.DecodeBool())
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSST) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.UniqueCount))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `UniqueCount`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.UniqueCount))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.SI == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSI(([]xlsxSI)(x.SI), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SI`)
				r.WriteMapElemValue()
				if x.SI == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSI(([]xlsxSI)(x.SI), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSST) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSST) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "UniqueCount":
			if r.TryDecodeAsNil() {
				x.UniqueCount = 0
			} else {
				x.UniqueCount = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "SI":
			if r.TryDecodeAsNil() {
				x.SI = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxSI((*[]xlsxSI)(&x.SI), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSST) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt12 := z.Extension(z.I2Rtid(x.XMLName)); yyxt12 != nil {
			z.DecExtension(x.XMLName, yyxt12)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.UniqueCount = 0
	} else {
		x.UniqueCount = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SI = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxSI((*[]xlsxSI)(&x.SI), d)
		}
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSI) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `T`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.R == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxR(([]xlsxR)(x.R), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `R`)
				r.WriteMapElemValue()
				if x.R == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxR(([]xlsxR)(x.R), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSI) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSI) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "T":
			if r.TryDecodeAsNil() {
				x.T = ""
			} else {
				x.T = (string)(r.DecodeString())
			}
		case "R":
			if r.TryDecodeAsNil() {
				x.R = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxR((*[]xlsxR)(&x.R), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSI) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.T = ""
	} else {
		x.T = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.R = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxR((*[]xlsxR)(&x.R), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxR) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `T`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.T))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxR) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxR) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "T":
			if r.TryDecodeAsNil() {
				x.T = ""
			} else {
				x.T = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxR) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.T = ""
	} else {
		x.T = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *HSL) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.H))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `H`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.H))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.S))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `S`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.S))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.L))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `L`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.L))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *HSL) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *HSL) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "H":
			if r.TryDecodeAsNil() {
				x.H = 0
			} else {
				x.H = (float64)(r.DecodeFloat64())
			}
		case "S":
			if r.TryDecodeAsNil() {
				x.S = 0
			} else {
				x.S = (float64)(r.DecodeFloat64())
			}
		case "L":
			if r.TryDecodeAsNil() {
				x.L = 0
			} else {
				x.L = (float64)(r.DecodeFloat64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *HSL) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.H = 0
	} else {
		x.H = (float64)(r.DecodeFloat64())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = 0
	} else {
		x.S = (float64)(r.DecodeFloat64())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.L = 0
	} else {
		x.L = (float64)(r.DecodeFloat64())
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *StreamFileBuilder) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *StreamFileBuilder) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *StreamFileBuilder) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *StreamFileBuilder) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *parsedNumberFormat) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *parsedNumberFormat) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *parsedNumberFormat) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *parsedNumberFormat) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *formatOptions) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *formatOptions) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *formatOptions) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *formatOptions) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxTypes) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Overrides == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxOverride(([]xlsxOverride)(x.Overrides), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Overrides`)
				r.WriteMapElemValue()
				if x.Overrides == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxOverride(([]xlsxOverride)(x.Overrides), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Defaults == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxDefault(([]xlsxDefault)(x.Defaults), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Defaults`)
				r.WriteMapElemValue()
				if x.Defaults == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxDefault(([]xlsxDefault)(x.Defaults), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxTypes) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxTypes) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Overrides":
			if r.TryDecodeAsNil() {
				x.Overrides = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxOverride((*[]xlsxOverride)(&x.Overrides), d)
				}
			}
		case "Defaults":
			if r.TryDecodeAsNil() {
				x.Defaults = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxDefault((*[]xlsxDefault)(&x.Defaults), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxTypes) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt12 := z.Extension(z.I2Rtid(x.XMLName)); yyxt12 != nil {
			z.DecExtension(x.XMLName, yyxt12)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Overrides = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxOverride((*[]xlsxOverride)(&x.Overrides), d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Defaults = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxDefault((*[]xlsxDefault)(&x.Defaults), d)
		}
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxOverride) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PartName))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PartName`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PartName))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ContentType))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ContentType`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ContentType))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxOverride) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxOverride) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "PartName":
			if r.TryDecodeAsNil() {
				x.PartName = ""
			} else {
				x.PartName = (string)(r.DecodeString())
			}
		case "ContentType":
			if r.TryDecodeAsNil() {
				x.ContentType = ""
			} else {
				x.ContentType = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxOverride) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PartName = ""
	} else {
		x.PartName = (string)(r.DecodeString())
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ContentType = ""
	} else {
		x.ContentType = (string)(r.DecodeString())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxDefault) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Extension))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Extension`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Extension))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ContentType))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ContentType`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ContentType))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxDefault) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxDefault) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Extension":
			if r.TryDecodeAsNil() {
				x.Extension = ""
			} else {
				x.Extension = (string)(r.DecodeString())
			}
		case "ContentType":
			if r.TryDecodeAsNil() {
				x.ContentType = ""
			} else {
				x.ContentType = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxDefault) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Extension = ""
	} else {
		x.Extension = (string)(r.DecodeString())
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ContentType = ""
	} else {
		x.ContentType = (string)(r.DecodeString())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *StreamFile) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *StreamFile) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *StreamFile) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *StreamFile) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *streamSheet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *streamSheet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *streamSheet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *streamSheet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxStyleSheet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(8)
			} else {
				r.WriteMapStart(8)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy9 := &x.Fonts
				yy9.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Fonts`)
				r.WriteMapElemValue()
				yy11 := &x.Fonts
				yy11.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy14 := &x.Fills
				yy14.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Fills`)
				r.WriteMapElemValue()
				yy16 := &x.Fills
				yy16.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy19 := &x.Borders
				yy19.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Borders`)
				r.WriteMapElemValue()
				yy21 := &x.Borders
				yy21.CodecEncodeSelf(e)
			}
			var yyn23 bool
			if x.CellStyles == nil {
				yyn23 = true
				goto LABEL23
			}
		LABEL23:
			if yyr2 || yy2arr2 {
				if yyn23 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.CellStyles == nil {
						r.EncodeNil()
					} else {
						x.CellStyles.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CellStyles`)
				r.WriteMapElemValue()
				if yyn23 {
					r.EncodeNil()
				} else {
					if x.CellStyles == nil {
						r.EncodeNil()
					} else {
						x.CellStyles.CodecEncodeSelf(e)
					}
				}
			}
			var yyn26 bool
			if x.CellStyleXfs == nil {
				yyn26 = true
				goto LABEL26
			}
		LABEL26:
			if yyr2 || yy2arr2 {
				if yyn26 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.CellStyleXfs == nil {
						r.EncodeNil()
					} else {
						x.CellStyleXfs.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CellStyleXfs`)
				r.WriteMapElemValue()
				if yyn26 {
					r.EncodeNil()
				} else {
					if x.CellStyleXfs == nil {
						r.EncodeNil()
					} else {
						x.CellStyleXfs.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy30 := &x.CellXfs
				yy30.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CellXfs`)
				r.WriteMapElemValue()
				yy32 := &x.CellXfs
				yy32.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy35 := &x.NumFmts
				yy35.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `NumFmts`)
				r.WriteMapElemValue()
				yy37 := &x.NumFmts
				yy37.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxStyleSheet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxStyleSheet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Fonts":
			if r.TryDecodeAsNil() {
				x.Fonts = xlsxFonts{}
			} else {
				x.Fonts.CodecDecodeSelf(d)
			}
		case "Fills":
			if r.TryDecodeAsNil() {
				x.Fills = xlsxFills{}
			} else {
				x.Fills.CodecDecodeSelf(d)
			}
		case "Borders":
			if r.TryDecodeAsNil() {
				x.Borders = xlsxBorders{}
			} else {
				x.Borders.CodecDecodeSelf(d)
			}
		case "CellStyles":
			if r.TryDecodeAsNil() {
				if true && x.CellStyles != nil {
					x.CellStyles = nil
				}
			} else {
				if x.CellStyles == nil {
					x.CellStyles = new(xlsxCellStyles)
				}

				x.CellStyles.CodecDecodeSelf(d)
			}
		case "CellStyleXfs":
			if r.TryDecodeAsNil() {
				if true && x.CellStyleXfs != nil {
					x.CellStyleXfs = nil
				}
			} else {
				if x.CellStyleXfs == nil {
					x.CellStyleXfs = new(xlsxCellStyleXfs)
				}

				x.CellStyleXfs.CodecDecodeSelf(d)
			}
		case "CellXfs":
			if r.TryDecodeAsNil() {
				x.CellXfs = xlsxCellXfs{}
			} else {
				x.CellXfs.CodecDecodeSelf(d)
			}
		case "NumFmts":
			if r.TryDecodeAsNil() {
				x.NumFmts = xlsxNumFmts{}
			} else {
				x.NumFmts.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxStyleSheet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj13 int
	var yyb13 bool
	var yyhl13 bool = l >= 0
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt15 := z.Extension(z.I2Rtid(x.XMLName)); yyxt15 != nil {
			z.DecExtension(x.XMLName, yyxt15)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Fonts = xlsxFonts{}
	} else {
		x.Fonts.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Fills = xlsxFills{}
	} else {
		x.Fills.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Borders = xlsxBorders{}
	} else {
		x.Borders.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.CellStyles != nil {
			x.CellStyles = nil
		}
	} else {
		if x.CellStyles == nil {
			x.CellStyles = new(xlsxCellStyles)
		}

		x.CellStyles.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.CellStyleXfs != nil {
			x.CellStyleXfs = nil
		}
	} else {
		if x.CellStyleXfs == nil {
			x.CellStyleXfs = new(xlsxCellStyleXfs)
		}

		x.CellStyleXfs.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CellXfs = xlsxCellXfs{}
	} else {
		x.CellXfs.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.NumFmts = xlsxNumFmts{}
	} else {
		x.NumFmts.CodecDecodeSelf(d)
	}
	for {
		yyj13++
		if yyhl13 {
			yyb13 = yyj13 > l
		} else {
			yyb13 = r.CheckBreak()
		}
		if yyb13 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj13-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxNumFmts) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.NumFmt == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxNumFmt(([]xlsxNumFmt)(x.NumFmt), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `NumFmt`)
				r.WriteMapElemValue()
				if x.NumFmt == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxNumFmt(([]xlsxNumFmt)(x.NumFmt), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxNumFmts) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxNumFmts) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "NumFmt":
			if r.TryDecodeAsNil() {
				x.NumFmt = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxNumFmt((*[]xlsxNumFmt)(&x.NumFmt), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxNumFmts) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.NumFmt = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxNumFmt((*[]xlsxNumFmt)(&x.NumFmt), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxNumFmt) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.NumFmtId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `NumFmtId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.NumFmtId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.FormatCode))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FormatCode`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.FormatCode))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxNumFmt) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxNumFmt) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "NumFmtId":
			if r.TryDecodeAsNil() {
				x.NumFmtId = 0
			} else {
				x.NumFmtId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FormatCode":
			if r.TryDecodeAsNil() {
				x.FormatCode = ""
			} else {
				x.FormatCode = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxNumFmt) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.NumFmtId = 0
	} else {
		x.NumFmtId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FormatCode = ""
	} else {
		x.FormatCode = (string)(r.DecodeString())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxFonts) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Font == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxFont(([]xlsxFont)(x.Font), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Font`)
				r.WriteMapElemValue()
				if x.Font == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxFont(([]xlsxFont)(x.Font), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxFonts) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxFonts) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Font":
			if r.TryDecodeAsNil() {
				x.Font = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxFont((*[]xlsxFont)(&x.Font), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxFonts) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt11 := z.Extension(z.I2Rtid(x.XMLName)); yyxt11 != nil {
			z.DecExtension(x.XMLName, yyxt11)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Font = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxFont((*[]xlsxFont)(&x.Font), d)
		}
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxFont) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(8)
			} else {
				r.WriteMapStart(8)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.Sz
				yy4.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sz`)
				r.WriteMapElemValue()
				yy6 := &x.Sz
				yy6.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy9 := &x.Name
				yy9.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				yy11 := &x.Name
				yy11.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy14 := &x.Family
				yy14.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Family`)
				r.WriteMapElemValue()
				yy16 := &x.Family
				yy16.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy19 := &x.Charset
				yy19.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Charset`)
				r.WriteMapElemValue()
				yy21 := &x.Charset
				yy21.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy24 := &x.Color
				yy24.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Color`)
				r.WriteMapElemValue()
				yy26 := &x.Color
				yy26.CodecEncodeSelf(e)
			}
			var yyn28 bool
			if x.B == nil {
				yyn28 = true
				goto LABEL28
			}
		LABEL28:
			if yyr2 || yy2arr2 {
				if yyn28 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.B == nil {
						r.EncodeNil()
					} else {
						x.B.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `B`)
				r.WriteMapElemValue()
				if yyn28 {
					r.EncodeNil()
				} else {
					if x.B == nil {
						r.EncodeNil()
					} else {
						x.B.CodecEncodeSelf(e)
					}
				}
			}
			var yyn31 bool
			if x.I == nil {
				yyn31 = true
				goto LABEL31
			}
		LABEL31:
			if yyr2 || yy2arr2 {
				if yyn31 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.I == nil {
						r.EncodeNil()
					} else {
						x.I.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `I`)
				r.WriteMapElemValue()
				if yyn31 {
					r.EncodeNil()
				} else {
					if x.I == nil {
						r.EncodeNil()
					} else {
						x.I.CodecEncodeSelf(e)
					}
				}
			}
			var yyn34 bool
			if x.U == nil {
				yyn34 = true
				goto LABEL34
			}
		LABEL34:
			if yyr2 || yy2arr2 {
				if yyn34 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.U == nil {
						r.EncodeNil()
					} else {
						x.U.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `U`)
				r.WriteMapElemValue()
				if yyn34 {
					r.EncodeNil()
				} else {
					if x.U == nil {
						r.EncodeNil()
					} else {
						x.U.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxFont) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxFont) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Sz":
			if r.TryDecodeAsNil() {
				x.Sz = xlsxVal{}
			} else {
				x.Sz.CodecDecodeSelf(d)
			}
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = xlsxVal{}
			} else {
				x.Name.CodecDecodeSelf(d)
			}
		case "Family":
			if r.TryDecodeAsNil() {
				x.Family = xlsxVal{}
			} else {
				x.Family.CodecDecodeSelf(d)
			}
		case "Charset":
			if r.TryDecodeAsNil() {
				x.Charset = xlsxVal{}
			} else {
				x.Charset.CodecDecodeSelf(d)
			}
		case "Color":
			if r.TryDecodeAsNil() {
				x.Color = xlsxColor{}
			} else {
				x.Color.CodecDecodeSelf(d)
			}
		case "B":
			if r.TryDecodeAsNil() {
				if true && x.B != nil {
					x.B = nil
				}
			} else {
				if x.B == nil {
					x.B = new(xlsxVal)
				}

				x.B.CodecDecodeSelf(d)
			}
		case "I":
			if r.TryDecodeAsNil() {
				if true && x.I != nil {
					x.I = nil
				}
			} else {
				if x.I == nil {
					x.I = new(xlsxVal)
				}

				x.I.CodecDecodeSelf(d)
			}
		case "U":
			if r.TryDecodeAsNil() {
				if true && x.U != nil {
					x.U = nil
				}
			} else {
				if x.U == nil {
					x.U = new(xlsxVal)
				}

				x.U.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxFont) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sz = xlsxVal{}
	} else {
		x.Sz.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = xlsxVal{}
	} else {
		x.Name.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Family = xlsxVal{}
	} else {
		x.Family.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Charset = xlsxVal{}
	} else {
		x.Charset.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Color = xlsxColor{}
	} else {
		x.Color.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.B != nil {
			x.B = nil
		}
	} else {
		if x.B == nil {
			x.B = new(xlsxVal)
		}

		x.B.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.I != nil {
			x.I = nil
		}
	} else {
		if x.I == nil {
			x.I = new(xlsxVal)
		}

		x.I.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = r.CheckBreak()
	}
	if yyb12 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.U != nil {
			x.U = nil
		}
	} else {
		if x.U == nil {
			x.U = new(xlsxVal)
		}

		x.U.CodecDecodeSelf(d)
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = r.CheckBreak()
		}
		if yyb12 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxVal) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Val))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Val`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Val))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxVal) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxVal) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Val":
			if r.TryDecodeAsNil() {
				x.Val = ""
			} else {
				x.Val = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxVal) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Val = ""
	} else {
		x.Val = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxFills) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Fill == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxFill(([]xlsxFill)(x.Fill), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Fill`)
				r.WriteMapElemValue()
				if x.Fill == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxFill(([]xlsxFill)(x.Fill), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxFills) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxFills) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Fill":
			if r.TryDecodeAsNil() {
				x.Fill = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxFill((*[]xlsxFill)(&x.Fill), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxFills) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Fill = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxFill((*[]xlsxFill)(&x.Fill), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxFill) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.PatternFill
				yy4.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PatternFill`)
				r.WriteMapElemValue()
				yy6 := &x.PatternFill
				yy6.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxFill) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxFill) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "PatternFill":
			if r.TryDecodeAsNil() {
				x.PatternFill = xlsxPatternFill{}
			} else {
				x.PatternFill.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxFill) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PatternFill = xlsxPatternFill{}
	} else {
		x.PatternFill.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxPatternFill) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PatternType))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PatternType`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.PatternType))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy7 := &x.FgColor
				yy7.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FgColor`)
				r.WriteMapElemValue()
				yy9 := &x.FgColor
				yy9.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy12 := &x.BgColor
				yy12.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BgColor`)
				r.WriteMapElemValue()
				yy14 := &x.BgColor
				yy14.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxPatternFill) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxPatternFill) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "PatternType":
			if r.TryDecodeAsNil() {
				x.PatternType = ""
			} else {
				x.PatternType = (string)(r.DecodeString())
			}
		case "FgColor":
			if r.TryDecodeAsNil() {
				x.FgColor = xlsxColor{}
			} else {
				x.FgColor.CodecDecodeSelf(d)
			}
		case "BgColor":
			if r.TryDecodeAsNil() {
				x.BgColor = xlsxColor{}
			} else {
				x.BgColor.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxPatternFill) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PatternType = ""
	} else {
		x.PatternType = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FgColor = xlsxColor{}
	} else {
		x.FgColor.CodecDecodeSelf(d)
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BgColor = xlsxColor{}
	} else {
		x.BgColor.CodecDecodeSelf(d)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxColor) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RGB))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `RGB`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RGB))
				}
			}
			var yyn6 bool
			if x.Theme == nil {
				yyn6 = true
				goto LABEL6
			}
		LABEL6:
			if yyr2 || yy2arr2 {
				if yyn6 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Theme == nil {
						r.EncodeNil()
					} else {
						yy7 := *x.Theme
						if false {
						} else {
							r.EncodeInt(int64(yy7))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Theme`)
				r.WriteMapElemValue()
				if yyn6 {
					r.EncodeNil()
				} else {
					if x.Theme == nil {
						r.EncodeNil()
					} else {
						yy9 := *x.Theme
						if false {
						} else {
							r.EncodeInt(int64(yy9))
						}
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Tint))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Tint`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Tint))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxColor) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxColor) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "RGB":
			if r.TryDecodeAsNil() {
				x.RGB = ""
			} else {
				x.RGB = (string)(r.DecodeString())
			}
		case "Theme":
			if r.TryDecodeAsNil() {
				if true && x.Theme != nil {
					x.Theme = nil
				}
			} else {
				if x.Theme == nil {
					x.Theme = new(int)
				}

				if false {
				} else {
					*x.Theme = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
				}
			}
		case "Tint":
			if r.TryDecodeAsNil() {
				x.Tint = 0
			} else {
				x.Tint = (float64)(r.DecodeFloat64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxColor) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.RGB = ""
	} else {
		x.RGB = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Theme != nil {
			x.Theme = nil
		}
	} else {
		if x.Theme == nil {
			x.Theme = new(int)
		}

		if false {
		} else {
			*x.Theme = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Tint = 0
	} else {
		x.Tint = (float64)(r.DecodeFloat64())
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxBorders) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Border == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxBorder(([]xlsxBorder)(x.Border), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Border`)
				r.WriteMapElemValue()
				if x.Border == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxBorder(([]xlsxBorder)(x.Border), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxBorders) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxBorders) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Border":
			if r.TryDecodeAsNil() {
				x.Border = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxBorder((*[]xlsxBorder)(&x.Border), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxBorders) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Border = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxBorder((*[]xlsxBorder)(&x.Border), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxBorder) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.Left
				yy4.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Left`)
				r.WriteMapElemValue()
				yy6 := &x.Left
				yy6.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy9 := &x.Right
				yy9.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Right`)
				r.WriteMapElemValue()
				yy11 := &x.Right
				yy11.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy14 := &x.Top
				yy14.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Top`)
				r.WriteMapElemValue()
				yy16 := &x.Top
				yy16.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy19 := &x.Bottom
				yy19.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Bottom`)
				r.WriteMapElemValue()
				yy21 := &x.Bottom
				yy21.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxBorder) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxBorder) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Left":
			if r.TryDecodeAsNil() {
				x.Left = xlsxLine{}
			} else {
				x.Left.CodecDecodeSelf(d)
			}
		case "Right":
			if r.TryDecodeAsNil() {
				x.Right = xlsxLine{}
			} else {
				x.Right.CodecDecodeSelf(d)
			}
		case "Top":
			if r.TryDecodeAsNil() {
				x.Top = xlsxLine{}
			} else {
				x.Top.CodecDecodeSelf(d)
			}
		case "Bottom":
			if r.TryDecodeAsNil() {
				x.Bottom = xlsxLine{}
			} else {
				x.Bottom.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxBorder) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Left = xlsxLine{}
	} else {
		x.Left.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Right = xlsxLine{}
	} else {
		x.Right.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Top = xlsxLine{}
	} else {
		x.Top.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Bottom = xlsxLine{}
	} else {
		x.Bottom.CodecDecodeSelf(d)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxLine) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Style))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Style`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Style))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy7 := &x.Color
				yy7.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Color`)
				r.WriteMapElemValue()
				yy9 := &x.Color
				yy9.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxLine) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxLine) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Style":
			if r.TryDecodeAsNil() {
				x.Style = ""
			} else {
				x.Style = (string)(r.DecodeString())
			}
		case "Color":
			if r.TryDecodeAsNil() {
				x.Color = xlsxColor{}
			} else {
				x.Color.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxLine) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Style = ""
	} else {
		x.Style = (string)(r.DecodeString())
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Color = xlsxColor{}
	} else {
		x.Color.CodecDecodeSelf(d)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCellStyles) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.CellStyle == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxCellStyle(([]xlsxCellStyle)(x.CellStyle), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CellStyle`)
				r.WriteMapElemValue()
				if x.CellStyle == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxCellStyle(([]xlsxCellStyle)(x.CellStyle), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCellStyles) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCellStyles) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "CellStyle":
			if r.TryDecodeAsNil() {
				x.CellStyle = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxCellStyle((*[]xlsxCellStyle)(&x.CellStyle), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCellStyles) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt11 := z.Extension(z.I2Rtid(x.XMLName)); yyxt11 != nil {
			z.DecExtension(x.XMLName, yyxt11)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CellStyle = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxCellStyle((*[]xlsxCellStyle)(&x.CellStyle), d)
		}
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCellStyle) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(7)
			} else {
				r.WriteMapStart(7)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			var yyn8 bool
			if x.BuiltInId == nil {
				yyn8 = true
				goto LABEL8
			}
		LABEL8:
			if yyr2 || yy2arr2 {
				if yyn8 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.BuiltInId == nil {
						r.EncodeNil()
					} else {
						yy9 := *x.BuiltInId
						if false {
						} else {
							r.EncodeInt(int64(yy9))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BuiltInId`)
				r.WriteMapElemValue()
				if yyn8 {
					r.EncodeNil()
				} else {
					if x.BuiltInId == nil {
						r.EncodeNil()
					} else {
						yy11 := *x.BuiltInId
						if false {
						} else {
							r.EncodeInt(int64(yy11))
						}
					}
				}
			}
			var yyn13 bool
			if x.CustomBuiltIn == nil {
				yyn13 = true
				goto LABEL13
			}
		LABEL13:
			if yyr2 || yy2arr2 {
				if yyn13 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.CustomBuiltIn == nil {
						r.EncodeNil()
					} else {
						yy14 := *x.CustomBuiltIn
						if false {
						} else {
							r.EncodeBool(bool(yy14))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CustomBuiltIn`)
				r.WriteMapElemValue()
				if yyn13 {
					r.EncodeNil()
				} else {
					if x.CustomBuiltIn == nil {
						r.EncodeNil()
					} else {
						yy16 := *x.CustomBuiltIn
						if false {
						} else {
							r.EncodeBool(bool(yy16))
						}
					}
				}
			}
			var yyn18 bool
			if x.Hidden == nil {
				yyn18 = true
				goto LABEL18
			}
		LABEL18:
			if yyr2 || yy2arr2 {
				if yyn18 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Hidden == nil {
						r.EncodeNil()
					} else {
						yy19 := *x.Hidden
						if false {
						} else {
							r.EncodeBool(bool(yy19))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if yyn18 {
					r.EncodeNil()
				} else {
					if x.Hidden == nil {
						r.EncodeNil()
					} else {
						yy21 := *x.Hidden
						if false {
						} else {
							r.EncodeBool(bool(yy21))
						}
					}
				}
			}
			var yyn23 bool
			if x.ILevel == nil {
				yyn23 = true
				goto LABEL23
			}
		LABEL23:
			if yyr2 || yy2arr2 {
				if yyn23 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.ILevel == nil {
						r.EncodeNil()
					} else {
						yy24 := *x.ILevel
						if false {
						} else {
							r.EncodeBool(bool(yy24))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ILevel`)
				r.WriteMapElemValue()
				if yyn23 {
					r.EncodeNil()
				} else {
					if x.ILevel == nil {
						r.EncodeNil()
					} else {
						yy26 := *x.ILevel
						if false {
						} else {
							r.EncodeBool(bool(yy26))
						}
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.XfId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XfId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.XfId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCellStyle) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCellStyle) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "BuiltInId":
			if r.TryDecodeAsNil() {
				if true && x.BuiltInId != nil {
					x.BuiltInId = nil
				}
			} else {
				if x.BuiltInId == nil {
					x.BuiltInId = new(int)
				}

				if false {
				} else {
					*x.BuiltInId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
				}
			}
		case "CustomBuiltIn":
			if r.TryDecodeAsNil() {
				if true && x.CustomBuiltIn != nil {
					x.CustomBuiltIn = nil
				}
			} else {
				if x.CustomBuiltIn == nil {
					x.CustomBuiltIn = new(bool)
				}

				if false {
				} else {
					*x.CustomBuiltIn = (bool)(r.DecodeBool())
				}
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				if true && x.Hidden != nil {
					x.Hidden = nil
				}
			} else {
				if x.Hidden == nil {
					x.Hidden = new(bool)
				}

				if false {
				} else {
					*x.Hidden = (bool)(r.DecodeBool())
				}
			}
		case "ILevel":
			if r.TryDecodeAsNil() {
				if true && x.ILevel != nil {
					x.ILevel = nil
				}
			} else {
				if x.ILevel == nil {
					x.ILevel = new(bool)
				}

				if false {
				} else {
					*x.ILevel = (bool)(r.DecodeBool())
				}
			}
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = ""
			} else {
				x.Name = (string)(r.DecodeString())
			}
		case "XfId":
			if r.TryDecodeAsNil() {
				x.XfId = 0
			} else {
				x.XfId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCellStyle) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj16 int
	var yyb16 bool
	var yyhl16 bool = l >= 0
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt18 := z.Extension(z.I2Rtid(x.XMLName)); yyxt18 != nil {
			z.DecExtension(x.XMLName, yyxt18)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.BuiltInId != nil {
			x.BuiltInId = nil
		}
	} else {
		if x.BuiltInId == nil {
			x.BuiltInId = new(int)
		}

		if false {
		} else {
			*x.BuiltInId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
		}
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.CustomBuiltIn != nil {
			x.CustomBuiltIn = nil
		}
	} else {
		if x.CustomBuiltIn == nil {
			x.CustomBuiltIn = new(bool)
		}

		if false {
		} else {
			*x.CustomBuiltIn = (bool)(r.DecodeBool())
		}
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Hidden != nil {
			x.Hidden = nil
		}
	} else {
		if x.Hidden == nil {
			x.Hidden = new(bool)
		}

		if false {
		} else {
			*x.Hidden = (bool)(r.DecodeBool())
		}
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.ILevel != nil {
			x.ILevel = nil
		}
	} else {
		if x.ILevel == nil {
			x.ILevel = new(bool)
		}

		if false {
		} else {
			*x.ILevel = (bool)(r.DecodeBool())
		}
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = ""
	} else {
		x.Name = (string)(r.DecodeString())
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = r.CheckBreak()
	}
	if yyb16 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XfId = 0
	} else {
		x.XfId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	for {
		yyj16++
		if yyhl16 {
			yyb16 = yyj16 > l
		} else {
			yyb16 = r.CheckBreak()
		}
		if yyb16 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj16-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCellStyleXfs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Xf == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxXf(([]xlsxXf)(x.Xf), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Xf`)
				r.WriteMapElemValue()
				if x.Xf == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxXf(([]xlsxXf)(x.Xf), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCellStyleXfs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCellStyleXfs) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Xf":
			if r.TryDecodeAsNil() {
				x.Xf = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxXf((*[]xlsxXf)(&x.Xf), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCellStyleXfs) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Xf = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxXf((*[]xlsxXf)(&x.Xf), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCellXfs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Count`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Count))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Xf == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxXf(([]xlsxXf)(x.Xf), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Xf`)
				r.WriteMapElemValue()
				if x.Xf == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxXf(([]xlsxXf)(x.Xf), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCellXfs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCellXfs) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Count":
			if r.TryDecodeAsNil() {
				x.Count = 0
			} else {
				x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Xf":
			if r.TryDecodeAsNil() {
				x.Xf = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxXf((*[]xlsxXf)(&x.Xf), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCellXfs) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Count = 0
	} else {
		x.Count = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Xf = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxXf((*[]xlsxXf)(&x.Xf), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxXf) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(12)
			} else {
				r.WriteMapStart(12)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyAlignment))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyAlignment`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyAlignment))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyBorder))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyBorder`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyBorder))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFont))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyFont`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFont))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFill))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyFill`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyFill))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyNumberFormat))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyNumberFormat`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyNumberFormat))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyProtection))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ApplyProtection`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ApplyProtection))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.BorderId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BorderId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.BorderId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FillId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FillId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FillId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FontId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FontId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FontId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.NumFmtId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `NumFmtId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.NumFmtId))
				}
			}
			var yyn33 bool
			if x.XfId == nil {
				yyn33 = true
				goto LABEL33
			}
		LABEL33:
			if yyr2 || yy2arr2 {
				if yyn33 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.XfId == nil {
						r.EncodeNil()
					} else {
						yy34 := *x.XfId
						if false {
						} else {
							r.EncodeInt(int64(yy34))
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XfId`)
				r.WriteMapElemValue()
				if yyn33 {
					r.EncodeNil()
				} else {
					if x.XfId == nil {
						r.EncodeNil()
					} else {
						yy36 := *x.XfId
						if false {
						} else {
							r.EncodeInt(int64(yy36))
						}
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy39 := &x.Alignment
				yy39.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Alignment`)
				r.WriteMapElemValue()
				yy41 := &x.Alignment
				yy41.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxXf) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxXf) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "ApplyAlignment":
			if r.TryDecodeAsNil() {
				x.ApplyAlignment = false
			} else {
				x.ApplyAlignment = (bool)(r.DecodeBool())
			}
		case "ApplyBorder":
			if r.TryDecodeAsNil() {
				x.ApplyBorder = false
			} else {
				x.ApplyBorder = (bool)(r.DecodeBool())
			}
		case "ApplyFont":
			if r.TryDecodeAsNil() {
				x.ApplyFont = false
			} else {
				x.ApplyFont = (bool)(r.DecodeBool())
			}
		case "ApplyFill":
			if r.TryDecodeAsNil() {
				x.ApplyFill = false
			} else {
				x.ApplyFill = (bool)(r.DecodeBool())
			}
		case "ApplyNumberFormat":
			if r.TryDecodeAsNil() {
				x.ApplyNumberFormat = false
			} else {
				x.ApplyNumberFormat = (bool)(r.DecodeBool())
			}
		case "ApplyProtection":
			if r.TryDecodeAsNil() {
				x.ApplyProtection = false
			} else {
				x.ApplyProtection = (bool)(r.DecodeBool())
			}
		case "BorderId":
			if r.TryDecodeAsNil() {
				x.BorderId = 0
			} else {
				x.BorderId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FillId":
			if r.TryDecodeAsNil() {
				x.FillId = 0
			} else {
				x.FillId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FontId":
			if r.TryDecodeAsNil() {
				x.FontId = 0
			} else {
				x.FontId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "NumFmtId":
			if r.TryDecodeAsNil() {
				x.NumFmtId = 0
			} else {
				x.NumFmtId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "XfId":
			if r.TryDecodeAsNil() {
				if true && x.XfId != nil {
					x.XfId = nil
				}
			} else {
				if x.XfId == nil {
					x.XfId = new(int)
				}

				if false {
				} else {
					*x.XfId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
				}
			}
		case "Alignment":
			if r.TryDecodeAsNil() {
				x.Alignment = xlsxAlignment{}
			} else {
				x.Alignment.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxXf) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj17 int
	var yyb17 bool
	var yyhl17 bool = l >= 0
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyAlignment = false
	} else {
		x.ApplyAlignment = (bool)(r.DecodeBool())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyBorder = false
	} else {
		x.ApplyBorder = (bool)(r.DecodeBool())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyFont = false
	} else {
		x.ApplyFont = (bool)(r.DecodeBool())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyFill = false
	} else {
		x.ApplyFill = (bool)(r.DecodeBool())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyNumberFormat = false
	} else {
		x.ApplyNumberFormat = (bool)(r.DecodeBool())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ApplyProtection = false
	} else {
		x.ApplyProtection = (bool)(r.DecodeBool())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BorderId = 0
	} else {
		x.BorderId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FillId = 0
	} else {
		x.FillId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FontId = 0
	} else {
		x.FontId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.NumFmtId = 0
	} else {
		x.NumFmtId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.XfId != nil {
			x.XfId = nil
		}
	} else {
		if x.XfId == nil {
			x.XfId = new(int)
		}

		if false {
		} else {
			*x.XfId = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
		}
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Alignment = xlsxAlignment{}
	} else {
		x.Alignment.CodecDecodeSelf(d)
	}
	for {
		yyj17++
		if yyhl17 {
			yyb17 = yyj17 > l
		} else {
			yyb17 = r.CheckBreak()
		}
		if yyb17 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj17-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxAlignment) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(6)
			} else {
				r.WriteMapStart(6)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Horizontal))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Horizontal`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Horizontal))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Indent))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Indent`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Indent))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShrinkToFit))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShrinkToFit`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShrinkToFit))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.TextRotation))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TextRotation`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.TextRotation))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Vertical))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Vertical`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Vertical))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.WrapText))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WrapText`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.WrapText))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxAlignment) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxAlignment) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Horizontal":
			if r.TryDecodeAsNil() {
				x.Horizontal = ""
			} else {
				x.Horizontal = (string)(r.DecodeString())
			}
		case "Indent":
			if r.TryDecodeAsNil() {
				x.Indent = 0
			} else {
				x.Indent = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "ShrinkToFit":
			if r.TryDecodeAsNil() {
				x.ShrinkToFit = false
			} else {
				x.ShrinkToFit = (bool)(r.DecodeBool())
			}
		case "TextRotation":
			if r.TryDecodeAsNil() {
				x.TextRotation = 0
			} else {
				x.TextRotation = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Vertical":
			if r.TryDecodeAsNil() {
				x.Vertical = ""
			} else {
				x.Vertical = (string)(r.DecodeString())
			}
		case "WrapText":
			if r.TryDecodeAsNil() {
				x.WrapText = false
			} else {
				x.WrapText = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxAlignment) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Horizontal = ""
	} else {
		x.Horizontal = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Indent = 0
	} else {
		x.Indent = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShrinkToFit = false
	} else {
		x.ShrinkToFit = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TextRotation = 0
	} else {
		x.TextRotation = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Vertical = ""
	} else {
		x.Vertical = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WrapText = false
	} else {
		x.WrapText = (bool)(r.DecodeBool())
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxTheme) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.ThemeElements
				yy4.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ThemeElements`)
				r.WriteMapElemValue()
				yy6 := &x.ThemeElements
				yy6.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxTheme) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxTheme) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "ThemeElements":
			if r.TryDecodeAsNil() {
				x.ThemeElements = xlsxThemeElements{}
			} else {
				x.ThemeElements.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxTheme) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ThemeElements = xlsxThemeElements{}
	} else {
		x.ThemeElements.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxThemeElements) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.ClrScheme
				yy4.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ClrScheme`)
				r.WriteMapElemValue()
				yy6 := &x.ClrScheme
				yy6.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxThemeElements) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxThemeElements) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "ClrScheme":
			if r.TryDecodeAsNil() {
				x.ClrScheme = xlsxClrScheme{}
			} else {
				x.ClrScheme.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxThemeElements) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ClrScheme = xlsxClrScheme{}
	} else {
		x.ClrScheme.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxClrScheme) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Children == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxClrSchemeEl(([]xlsxClrSchemeEl)(x.Children), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Children`)
				r.WriteMapElemValue()
				if x.Children == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxClrSchemeEl(([]xlsxClrSchemeEl)(x.Children), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxClrScheme) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxClrScheme) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = ""
			} else {
				x.Name = (string)(r.DecodeString())
			}
		case "Children":
			if r.TryDecodeAsNil() {
				x.Children = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxClrSchemeEl((*[]xlsxClrSchemeEl)(&x.Children), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxClrScheme) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = ""
	} else {
		x.Name = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Children = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxClrSchemeEl((*[]xlsxClrSchemeEl)(&x.Children), d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxClrSchemeEl) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			var yyn8 bool
			if x.SysClr == nil {
				yyn8 = true
				goto LABEL8
			}
		LABEL8:
			if yyr2 || yy2arr2 {
				if yyn8 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.SysClr == nil {
						r.EncodeNil()
					} else {
						x.SysClr.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SysClr`)
				r.WriteMapElemValue()
				if yyn8 {
					r.EncodeNil()
				} else {
					if x.SysClr == nil {
						r.EncodeNil()
					} else {
						x.SysClr.CodecEncodeSelf(e)
					}
				}
			}
			var yyn11 bool
			if x.SrgbClr == nil {
				yyn11 = true
				goto LABEL11
			}
		LABEL11:
			if yyr2 || yy2arr2 {
				if yyn11 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.SrgbClr == nil {
						r.EncodeNil()
					} else {
						x.SrgbClr.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SrgbClr`)
				r.WriteMapElemValue()
				if yyn11 {
					r.EncodeNil()
				} else {
					if x.SrgbClr == nil {
						r.EncodeNil()
					} else {
						x.SrgbClr.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxClrSchemeEl) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxClrSchemeEl) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "SysClr":
			if r.TryDecodeAsNil() {
				if true && x.SysClr != nil {
					x.SysClr = nil
				}
			} else {
				if x.SysClr == nil {
					x.SysClr = new(xlsxSysClr)
				}

				x.SysClr.CodecDecodeSelf(d)
			}
		case "SrgbClr":
			if r.TryDecodeAsNil() {
				if true && x.SrgbClr != nil {
					x.SrgbClr = nil
				}
			} else {
				if x.SrgbClr == nil {
					x.SrgbClr = new(xlsxSrgbClr)
				}

				x.SrgbClr.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxClrSchemeEl) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt10 := z.Extension(z.I2Rtid(x.XMLName)); yyxt10 != nil {
			z.DecExtension(x.XMLName, yyxt10)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.SysClr != nil {
			x.SysClr = nil
		}
	} else {
		if x.SysClr == nil {
			x.SysClr = new(xlsxSysClr)
		}

		x.SysClr.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.SrgbClr != nil {
			x.SrgbClr = nil
		}
	} else {
		if x.SrgbClr == nil {
			x.SrgbClr = new(xlsxSrgbClr)
		}

		x.SrgbClr.CodecDecodeSelf(d)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSysClr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Val))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Val`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Val))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LastClr))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `LastClr`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LastClr))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSysClr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSysClr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Val":
			if r.TryDecodeAsNil() {
				x.Val = ""
			} else {
				x.Val = (string)(r.DecodeString())
			}
		case "LastClr":
			if r.TryDecodeAsNil() {
				x.LastClr = ""
			} else {
				x.LastClr = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSysClr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Val = ""
	} else {
		x.Val = (string)(r.DecodeString())
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.LastClr = ""
	} else {
		x.LastClr = (string)(r.DecodeString())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSrgbClr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Val))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Val`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Val))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSrgbClr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSrgbClr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Val":
			if r.TryDecodeAsNil() {
				x.Val = ""
			} else {
				x.Val = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSrgbClr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Val = ""
	} else {
		x.Val = (string)(r.DecodeString())
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x CellType) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.EncExtension(x, yyxt1)
	} else {
		r.EncodeInt(int64(x))
	}
}

func (x *CellType) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		*x = (CellType)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
}

func (x *Cell) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(6)
			} else {
				r.WriteMapStart(6)
			}
			var yyn3 bool
			if x.Row == nil {
				yyn3 = true
				goto LABEL3
			}
		LABEL3:
			if yyr2 || yy2arr2 {
				if yyn3 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Row == nil {
						r.EncodeNil()
					} else {
						x.Row.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Row`)
				r.WriteMapElemValue()
				if yyn3 {
					r.EncodeNil()
				} else {
					if x.Row == nil {
						r.EncodeNil()
					} else {
						x.Row.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Value))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Value`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Value))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.NumFmt))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `NumFmt`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.NumFmt))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.HMerge))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `HMerge`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.HMerge))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.VMerge))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `VMerge`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.VMerge))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Cell) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Cell) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Row":
			if r.TryDecodeAsNil() {
				if true && x.Row != nil {
					x.Row = nil
				}
			} else {
				if x.Row == nil {
					x.Row = new(Row)
				}

				x.Row.CodecDecodeSelf(d)
			}
		case "Value":
			if r.TryDecodeAsNil() {
				x.Value = ""
			} else {
				x.Value = (string)(r.DecodeString())
			}
		case "NumFmt":
			if r.TryDecodeAsNil() {
				x.NumFmt = ""
			} else {
				x.NumFmt = (string)(r.DecodeString())
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "HMerge":
			if r.TryDecodeAsNil() {
				x.HMerge = 0
			} else {
				x.HMerge = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "VMerge":
			if r.TryDecodeAsNil() {
				x.VMerge = 0
			} else {
				x.VMerge = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Cell) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Row != nil {
			x.Row = nil
		}
	} else {
		if x.Row == nil {
			x.Row = new(Row)
		}

		x.Row.CodecDecodeSelf(d)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Value = ""
	} else {
		x.Value = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.NumFmt = ""
	} else {
		x.NumFmt = (string)(r.DecodeString())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.HMerge = 0
	} else {
		x.HMerge = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.VMerge = 0
	} else {
		x.VMerge = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *DateTimeOptions) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			var yyn3 bool
			if x.Location == nil {
				yyn3 = true
				goto LABEL3
			}
		LABEL3:
			if yyr2 || yy2arr2 {
				if yyn3 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Location == nil {
						r.EncodeNil()
					} else {
						if false {
						} else if yyxt4 := z.Extension(z.I2Rtid(x.Location)); yyxt4 != nil {
							z.EncExtension(x.Location, yyxt4)
						} else {
							z.EncFallback(x.Location)
						}
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Location`)
				r.WriteMapElemValue()
				if yyn3 {
					r.EncodeNil()
				} else {
					if x.Location == nil {
						r.EncodeNil()
					} else {
						if false {
						} else if yyxt5 := z.Extension(z.I2Rtid(x.Location)); yyxt5 != nil {
							z.EncExtension(x.Location, yyxt5)
						} else {
							z.EncFallback(x.Location)
						}
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ExcelTimeFormat))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ExcelTimeFormat`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ExcelTimeFormat))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *DateTimeOptions) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *DateTimeOptions) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Location":
			if r.TryDecodeAsNil() {
				if true && x.Location != nil {
					x.Location = nil
				}
			} else {
				if x.Location == nil {
					x.Location = new(time.Location)
				}

				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.Location)); yyxt5 != nil {
					z.DecExtension(x.Location, yyxt5)
				} else {
					z.DecFallback(x.Location, false)
				}
			}
		case "ExcelTimeFormat":
			if r.TryDecodeAsNil() {
				x.ExcelTimeFormat = ""
			} else {
				x.ExcelTimeFormat = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *DateTimeOptions) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Location != nil {
			x.Location = nil
		}
	} else {
		if x.Location == nil {
			x.Location = new(time.Location)
		}

		if false {
		} else if yyxt9 := z.Extension(z.I2Rtid(x.Location)); yyxt9 != nil {
			z.DecExtension(x.Location, yyxt9)
		} else {
			z.DecFallback(x.Location, false)
		}
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ExcelTimeFormat = ""
	} else {
		x.ExcelTimeFormat = (string)(r.DecodeString())
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Col) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(6)
			} else {
				r.WriteMapStart(6)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Min))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Min`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Min))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.Max))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Max`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.Max))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Width))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Width`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Width))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Collapsed))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Collapsed`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Collapsed))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevel`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Col) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Col) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Min":
			if r.TryDecodeAsNil() {
				x.Min = 0
			} else {
				x.Min = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Max":
			if r.TryDecodeAsNil() {
				x.Max = 0
			} else {
				x.Max = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "Width":
			if r.TryDecodeAsNil() {
				x.Width = 0
			} else {
				x.Width = (float64)(r.DecodeFloat64())
			}
		case "Collapsed":
			if r.TryDecodeAsNil() {
				x.Collapsed = false
			} else {
				x.Collapsed = (bool)(r.DecodeBool())
			}
		case "OutlineLevel":
			if r.TryDecodeAsNil() {
				x.OutlineLevel = 0
			} else {
				x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Col) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Min = 0
	} else {
		x.Min = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Max = 0
	} else {
		x.Max = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Width = 0
	} else {
		x.Width = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Collapsed = false
	} else {
		x.Collapsed = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevel = 0
	} else {
		x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *File) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Date1904))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Date1904`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Date1904))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Sheets == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoSheet(([]*Sheet)(x.Sheets), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sheets`)
				r.WriteMapElemValue()
				if x.Sheets == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoSheet(([]*Sheet)(x.Sheets), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Sheet == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encMapstringPtrtoSheet((map[string]*Sheet)(x.Sheet), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sheet`)
				r.WriteMapElemValue()
				if x.Sheet == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encMapstringPtrtoSheet((map[string]*Sheet)(x.Sheet), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.DefinedNames == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoxlsxDefinedName(([]*xlsxDefinedName)(x.DefinedNames), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefinedNames`)
				r.WriteMapElemValue()
				if x.DefinedNames == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoxlsxDefinedName(([]*xlsxDefinedName)(x.DefinedNames), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *File) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *File) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Date1904":
			if r.TryDecodeAsNil() {
				x.Date1904 = false
			} else {
				x.Date1904 = (bool)(r.DecodeBool())
			}
		case "Sheets":
			if r.TryDecodeAsNil() {
				x.Sheets = nil
			} else {
				if false {
				} else {
					h.decSlicePtrtoSheet((*[]*Sheet)(&x.Sheets), d)
				}
			}
		case "Sheet":
			if r.TryDecodeAsNil() {
				x.Sheet = nil
			} else {
				if false {
				} else {
					h.decMapstringPtrtoSheet((*map[string]*Sheet)(&x.Sheet), d)
				}
			}
		case "DefinedNames":
			if r.TryDecodeAsNil() {
				x.DefinedNames = nil
			} else {
				if false {
				} else {
					h.decSlicePtrtoxlsxDefinedName((*[]*xlsxDefinedName)(&x.DefinedNames), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *File) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj11 int
	var yyb11 bool
	var yyhl11 bool = l >= 0
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = r.CheckBreak()
	}
	if yyb11 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Date1904 = false
	} else {
		x.Date1904 = (bool)(r.DecodeBool())
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = r.CheckBreak()
	}
	if yyb11 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sheets = nil
	} else {
		if false {
		} else {
			h.decSlicePtrtoSheet((*[]*Sheet)(&x.Sheets), d)
		}
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = r.CheckBreak()
	}
	if yyb11 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sheet = nil
	} else {
		if false {
		} else {
			h.decMapstringPtrtoSheet((*map[string]*Sheet)(&x.Sheet), d)
		}
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = r.CheckBreak()
	}
	if yyb11 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefinedNames = nil
	} else {
		if false {
		} else {
			h.decSlicePtrtoxlsxDefinedName((*[]*xlsxDefinedName)(&x.DefinedNames), d)
		}
	}
	for {
		yyj11++
		if yyhl11 {
			yyb11 = yyj11 > l
		} else {
			yyb11 = r.CheckBreak()
		}
		if yyb11 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj11-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Sheet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(11)
			} else {
				r.WriteMapStart(11)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			}
			var yyn6 bool
			if x.File == nil {
				yyn6 = true
				goto LABEL6
			}
		LABEL6:
			if yyr2 || yy2arr2 {
				if yyn6 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.File == nil {
						r.EncodeNil()
					} else {
						x.File.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `File`)
				r.WriteMapElemValue()
				if yyn6 {
					r.EncodeNil()
				} else {
					if x.File == nil {
						r.EncodeNil()
					} else {
						x.File.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Rows == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoRow(([]*Row)(x.Rows), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Rows`)
				r.WriteMapElemValue()
				if x.Rows == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoRow(([]*Row)(x.Rows), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Cols == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoCol(([]*Col)(x.Cols), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Cols`)
				r.WriteMapElemValue()
				if x.Cols == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoCol(([]*Col)(x.Cols), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.MaxRow))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `MaxRow`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.MaxRow))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.MaxCol))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `MaxCol`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.MaxCol))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Selected))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Selected`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Selected))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.SheetViews == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSliceSheetView(([]SheetView)(x.SheetViews), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetViews`)
				r.WriteMapElemValue()
				if x.SheetViews == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSliceSheetView(([]SheetView)(x.SheetViews), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy31 := &x.SheetFormat
				yy31.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetFormat`)
				r.WriteMapElemValue()
				yy33 := &x.SheetFormat
				yy33.CodecEncodeSelf(e)
			}
			var yyn35 bool
			if x.AutoFilter == nil {
				yyn35 = true
				goto LABEL35
			}
		LABEL35:
			if yyr2 || yy2arr2 {
				if yyn35 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.AutoFilter == nil {
						r.EncodeNil()
					} else {
						x.AutoFilter.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `AutoFilter`)
				r.WriteMapElemValue()
				if yyn35 {
					r.EncodeNil()
				} else {
					if x.AutoFilter == nil {
						r.EncodeNil()
					} else {
						x.AutoFilter.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Sheet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Sheet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = ""
			} else {
				x.Name = (string)(r.DecodeString())
			}
		case "File":
			if r.TryDecodeAsNil() {
				if true && x.File != nil {
					x.File = nil
				}
			} else {
				if x.File == nil {
					x.File = new(File)
				}

				x.File.CodecDecodeSelf(d)
			}
		case "Rows":
			if r.TryDecodeAsNil() {
				x.Rows = nil
			} else {
				if false {
				} else {
					h.decSlicePtrtoRow((*[]*Row)(&x.Rows), d)
				}
			}
		case "Cols":
			if r.TryDecodeAsNil() {
				x.Cols = nil
			} else {
				if false {
				} else {
					h.decSlicePtrtoCol((*[]*Col)(&x.Cols), d)
				}
			}
		case "MaxRow":
			if r.TryDecodeAsNil() {
				x.MaxRow = 0
			} else {
				x.MaxRow = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "MaxCol":
			if r.TryDecodeAsNil() {
				x.MaxCol = 0
			} else {
				x.MaxCol = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "Selected":
			if r.TryDecodeAsNil() {
				x.Selected = false
			} else {
				x.Selected = (bool)(r.DecodeBool())
			}
		case "SheetViews":
			if r.TryDecodeAsNil() {
				x.SheetViews = nil
			} else {
				if false {
				} else {
					h.decSliceSheetView((*[]SheetView)(&x.SheetViews), d)
				}
			}
		case "SheetFormat":
			if r.TryDecodeAsNil() {
				x.SheetFormat = SheetFormat{}
			} else {
				x.SheetFormat.CodecDecodeSelf(d)
			}
		case "AutoFilter":
			if r.TryDecodeAsNil() {
				if true && x.AutoFilter != nil {
					x.AutoFilter = nil
				}
			} else {
				if x.AutoFilter == nil {
					x.AutoFilter = new(AutoFilter)
				}

				x.AutoFilter.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Sheet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj18 int
	var yyb18 bool
	var yyhl18 bool = l >= 0
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = ""
	} else {
		x.Name = (string)(r.DecodeString())
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.File != nil {
			x.File = nil
		}
	} else {
		if x.File == nil {
			x.File = new(File)
		}

		x.File.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Rows = nil
	} else {
		if false {
		} else {
			h.decSlicePtrtoRow((*[]*Row)(&x.Rows), d)
		}
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Cols = nil
	} else {
		if false {
		} else {
			h.decSlicePtrtoCol((*[]*Col)(&x.Cols), d)
		}
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.MaxRow = 0
	} else {
		x.MaxRow = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.MaxCol = 0
	} else {
		x.MaxCol = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Selected = false
	} else {
		x.Selected = (bool)(r.DecodeBool())
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetViews = nil
	} else {
		if false {
		} else {
			h.decSliceSheetView((*[]SheetView)(&x.SheetViews), d)
		}
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetFormat = SheetFormat{}
	} else {
		x.SheetFormat.CodecDecodeSelf(d)
	}
	yyj18++
	if yyhl18 {
		yyb18 = yyj18 > l
	} else {
		yyb18 = r.CheckBreak()
	}
	if yyb18 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.AutoFilter != nil {
			x.AutoFilter = nil
		}
	} else {
		if x.AutoFilter == nil {
			x.AutoFilter = new(AutoFilter)
		}

		x.AutoFilter.CodecDecodeSelf(d)
	}
	for {
		yyj18++
		if yyhl18 {
			yyb18 = yyj18 > l
		} else {
			yyb18 = r.CheckBreak()
		}
		if yyb18 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj18-1, "")
	}
	r.ReadArrayEnd()
}

func (x *SheetView) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			var yyn3 bool
			if x.Pane == nil {
				yyn3 = true
				goto LABEL3
			}
		LABEL3:
			if yyr2 || yy2arr2 {
				if yyn3 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Pane == nil {
						r.EncodeNil()
					} else {
						x.Pane.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Pane`)
				r.WriteMapElemValue()
				if yyn3 {
					r.EncodeNil()
				} else {
					if x.Pane == nil {
						r.EncodeNil()
					} else {
						x.Pane.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *SheetView) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *SheetView) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Pane":
			if r.TryDecodeAsNil() {
				if true && x.Pane != nil {
					x.Pane = nil
				}
			} else {
				if x.Pane == nil {
					x.Pane = new(Pane)
				}

				x.Pane.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *SheetView) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Pane != nil {
			x.Pane = nil
		}
	} else {
		if x.Pane == nil {
			x.Pane = new(Pane)
		}

		x.Pane.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Pane) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(5)
			} else {
				r.WriteMapStart(5)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.XSplit))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XSplit`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.XSplit))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.YSplit))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `YSplit`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.YSplit))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TopLeftCell`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ActivePane))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ActivePane`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ActivePane))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.State))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `State`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.State))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Pane) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Pane) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XSplit":
			if r.TryDecodeAsNil() {
				x.XSplit = 0
			} else {
				x.XSplit = (float64)(r.DecodeFloat64())
			}
		case "YSplit":
			if r.TryDecodeAsNil() {
				x.YSplit = 0
			} else {
				x.YSplit = (float64)(r.DecodeFloat64())
			}
		case "TopLeftCell":
			if r.TryDecodeAsNil() {
				x.TopLeftCell = ""
			} else {
				x.TopLeftCell = (string)(r.DecodeString())
			}
		case "ActivePane":
			if r.TryDecodeAsNil() {
				x.ActivePane = ""
			} else {
				x.ActivePane = (string)(r.DecodeString())
			}
		case "State":
			if r.TryDecodeAsNil() {
				x.State = ""
			} else {
				x.State = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Pane) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XSplit = 0
	} else {
		x.XSplit = (float64)(r.DecodeFloat64())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.YSplit = 0
	} else {
		x.YSplit = (float64)(r.DecodeFloat64())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TopLeftCell = ""
	} else {
		x.TopLeftCell = (string)(r.DecodeString())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ActivePane = ""
	} else {
		x.ActivePane = (string)(r.DecodeString())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.State = ""
	} else {
		x.State = (string)(r.DecodeString())
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x *SheetFormat) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultColWidth))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefaultColWidth`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultColWidth))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultRowHeight))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefaultRowHeight`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.DefaultRowHeight))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelCol))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevelCol`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelCol))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelRow))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevelRow`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevelRow))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *SheetFormat) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *SheetFormat) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "DefaultColWidth":
			if r.TryDecodeAsNil() {
				x.DefaultColWidth = 0
			} else {
				x.DefaultColWidth = (float64)(r.DecodeFloat64())
			}
		case "DefaultRowHeight":
			if r.TryDecodeAsNil() {
				x.DefaultRowHeight = 0
			} else {
				x.DefaultRowHeight = (float64)(r.DecodeFloat64())
			}
		case "OutlineLevelCol":
			if r.TryDecodeAsNil() {
				x.OutlineLevelCol = 0
			} else {
				x.OutlineLevelCol = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "OutlineLevelRow":
			if r.TryDecodeAsNil() {
				x.OutlineLevelRow = 0
			} else {
				x.OutlineLevelRow = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *SheetFormat) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefaultColWidth = 0
	} else {
		x.DefaultColWidth = (float64)(r.DecodeFloat64())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefaultRowHeight = 0
	} else {
		x.DefaultRowHeight = (float64)(r.DecodeFloat64())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevelCol = 0
	} else {
		x.OutlineLevelCol = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevelRow = 0
	} else {
		x.OutlineLevelRow = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *AutoFilter) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TopLeftCell`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.TopLeftCell))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.BottomRightCell))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BottomRightCell`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.BottomRightCell))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *AutoFilter) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *AutoFilter) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "TopLeftCell":
			if r.TryDecodeAsNil() {
				x.TopLeftCell = ""
			} else {
				x.TopLeftCell = (string)(r.DecodeString())
			}
		case "BottomRightCell":
			if r.TryDecodeAsNil() {
				x.BottomRightCell = ""
			} else {
				x.BottomRightCell = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *AutoFilter) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TopLeftCell = ""
	} else {
		x.TopLeftCell = (string)(r.DecodeString())
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BottomRightCell = ""
	} else {
		x.BottomRightCell = (string)(r.DecodeString())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *Row) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(5)
			} else {
				r.WriteMapStart(5)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Cells == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoCell(([]*Cell)(x.Cells), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Cells`)
				r.WriteMapElemValue()
				if x.Cells == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicePtrtoCell(([]*Cell)(x.Cells), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			var yyn9 bool
			if x.Sheet == nil {
				yyn9 = true
				goto LABEL9
			}
		LABEL9:
			if yyr2 || yy2arr2 {
				if yyn9 {
					r.WriteArrayElem()
					r.EncodeNil()
				} else {
					r.WriteArrayElem()
					if x.Sheet == nil {
						r.EncodeNil()
					} else {
						x.Sheet.CodecEncodeSelf(e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sheet`)
				r.WriteMapElemValue()
				if yyn9 {
					r.EncodeNil()
				} else {
					if x.Sheet == nil {
						r.EncodeNil()
					} else {
						x.Sheet.CodecEncodeSelf(e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Height))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Height`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.Height))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `OutlineLevel`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeUint(uint64(x.OutlineLevel))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *Row) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *Row) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Cells":
			if r.TryDecodeAsNil() {
				x.Cells = nil
			} else {
				if false {
				} else {
					h.decSlicePtrtoCell((*[]*Cell)(&x.Cells), d)
				}
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "Sheet":
			if r.TryDecodeAsNil() {
				if true && x.Sheet != nil {
					x.Sheet = nil
				}
			} else {
				if x.Sheet == nil {
					x.Sheet = new(Sheet)
				}

				x.Sheet.CodecDecodeSelf(d)
			}
		case "Height":
			if r.TryDecodeAsNil() {
				x.Height = 0
			} else {
				x.Height = (float64)(r.DecodeFloat64())
			}
		case "OutlineLevel":
			if r.TryDecodeAsNil() {
				x.OutlineLevel = 0
			} else {
				x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *Row) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Cells = nil
	} else {
		if false {
		} else {
			h.decSlicePtrtoCell((*[]*Cell)(&x.Cells), d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		if true && x.Sheet != nil {
			x.Sheet = nil
		}
	} else {
		if x.Sheet == nil {
			x.Sheet = new(Sheet)
		}

		x.Sheet.CodecDecodeSelf(d)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Height = 0
	} else {
		x.Height = (float64)(r.DecodeFloat64())
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = r.CheckBreak()
	}
	if yyb10 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.OutlineLevel = 0
	} else {
		x.OutlineLevel = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = r.CheckBreak()
		}
		if yyb10 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxWorkbookRels) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(2)
			} else {
				r.WriteMapStart(2)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Relationships == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxWorkbookRelation(([]xlsxWorkbookRelation)(x.Relationships), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Relationships`)
				r.WriteMapElemValue()
				if x.Relationships == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxWorkbookRelation(([]xlsxWorkbookRelation)(x.Relationships), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorkbookRels) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorkbookRels) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "Relationships":
			if r.TryDecodeAsNil() {
				x.Relationships = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxWorkbookRelation((*[]xlsxWorkbookRelation)(&x.Relationships), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorkbookRels) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt10 := z.Extension(z.I2Rtid(x.XMLName)); yyxt10 != nil {
			z.DecExtension(x.XMLName, yyxt10)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Relationships = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxWorkbookRelation((*[]xlsxWorkbookRelation)(&x.Relationships), d)
		}
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxWorkbookRelation) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(3)
			} else {
				r.WriteMapStart(3)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Id))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Id`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Id))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Target))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Target`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Target))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Type))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Type`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Type))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorkbookRelation) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorkbookRelation) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Id":
			if r.TryDecodeAsNil() {
				x.Id = ""
			} else {
				x.Id = (string)(r.DecodeString())
			}
		case "Target":
			if r.TryDecodeAsNil() {
				x.Target = ""
			} else {
				x.Target = (string)(r.DecodeString())
			}
		case "Type":
			if r.TryDecodeAsNil() {
				x.Type = ""
			} else {
				x.Type = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorkbookRelation) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Id = ""
	} else {
		x.Id = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Target = ""
	} else {
		x.Target = (string)(r.DecodeString())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Type = ""
	} else {
		x.Type = (string)(r.DecodeString())
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxWorkbook) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(8)
			} else {
				r.WriteMapStart(8)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy4 := &x.XMLName
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(yy4)); yyxt5 != nil {
					z.EncExtension(yy4, yyxt5)
				} else {
					z.EncFallback(yy4)
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XMLName`)
				r.WriteMapElemValue()
				yy6 := &x.XMLName
				if false {
				} else if yyxt7 := z.Extension(z.I2Rtid(yy6)); yyxt7 != nil {
					z.EncExtension(yy6, yyxt7)
				} else {
					z.EncFallback(yy6)
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy9 := &x.FileVersion
				yy9.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FileVersion`)
				r.WriteMapElemValue()
				yy11 := &x.FileVersion
				yy11.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy14 := &x.WorkbookPr
				yy14.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WorkbookPr`)
				r.WriteMapElemValue()
				yy16 := &x.WorkbookPr
				yy16.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy19 := &x.WorkbookProtection
				yy19.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WorkbookProtection`)
				r.WriteMapElemValue()
				yy21 := &x.WorkbookProtection
				yy21.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy24 := &x.BookViews
				yy24.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BookViews`)
				r.WriteMapElemValue()
				yy26 := &x.BookViews
				yy26.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy29 := &x.Sheets
				yy29.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sheets`)
				r.WriteMapElemValue()
				yy31 := &x.Sheets
				yy31.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy34 := &x.DefinedNames
				yy34.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefinedNames`)
				r.WriteMapElemValue()
				yy36 := &x.DefinedNames
				yy36.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				yy39 := &x.CalcPr
				yy39.CodecEncodeSelf(e)
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CalcPr`)
				r.WriteMapElemValue()
				yy41 := &x.CalcPr
				yy41.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorkbook) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorkbook) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "XMLName":
			if r.TryDecodeAsNil() {
				x.XMLName = pkg1_xml.Name{}
			} else {
				if false {
				} else if yyxt5 := z.Extension(z.I2Rtid(x.XMLName)); yyxt5 != nil {
					z.DecExtension(x.XMLName, yyxt5)
				} else {
					z.DecFallback(&x.XMLName, false)
				}
			}
		case "FileVersion":
			if r.TryDecodeAsNil() {
				x.FileVersion = xlsxFileVersion{}
			} else {
				x.FileVersion.CodecDecodeSelf(d)
			}
		case "WorkbookPr":
			if r.TryDecodeAsNil() {
				x.WorkbookPr = xlsxWorkbookPr{}
			} else {
				x.WorkbookPr.CodecDecodeSelf(d)
			}
		case "WorkbookProtection":
			if r.TryDecodeAsNil() {
				x.WorkbookProtection = xlsxWorkbookProtection{}
			} else {
				x.WorkbookProtection.CodecDecodeSelf(d)
			}
		case "BookViews":
			if r.TryDecodeAsNil() {
				x.BookViews = xlsxBookViews{}
			} else {
				x.BookViews.CodecDecodeSelf(d)
			}
		case "Sheets":
			if r.TryDecodeAsNil() {
				x.Sheets = xlsxSheets{}
			} else {
				x.Sheets.CodecDecodeSelf(d)
			}
		case "DefinedNames":
			if r.TryDecodeAsNil() {
				x.DefinedNames = xlsxDefinedNames{}
			} else {
				x.DefinedNames.CodecDecodeSelf(d)
			}
		case "CalcPr":
			if r.TryDecodeAsNil() {
				x.CalcPr = xlsxCalcPr{}
			} else {
				x.CalcPr.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorkbook) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj13 int
	var yyb13 bool
	var yyhl13 bool = l >= 0
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XMLName = pkg1_xml.Name{}
	} else {
		if false {
		} else if yyxt15 := z.Extension(z.I2Rtid(x.XMLName)); yyxt15 != nil {
			z.DecExtension(x.XMLName, yyxt15)
		} else {
			z.DecFallback(&x.XMLName, false)
		}
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FileVersion = xlsxFileVersion{}
	} else {
		x.FileVersion.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WorkbookPr = xlsxWorkbookPr{}
	} else {
		x.WorkbookPr.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WorkbookProtection = xlsxWorkbookProtection{}
	} else {
		x.WorkbookProtection.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BookViews = xlsxBookViews{}
	} else {
		x.BookViews.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sheets = xlsxSheets{}
	} else {
		x.Sheets.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefinedNames = xlsxDefinedNames{}
	} else {
		x.DefinedNames.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = r.CheckBreak()
	}
	if yyb13 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CalcPr = xlsxCalcPr{}
	} else {
		x.CalcPr.CodecDecodeSelf(d)
	}
	for {
		yyj13++
		if yyhl13 {
			yyb13 = yyj13 > l
		} else {
			yyb13 = r.CheckBreak()
		}
		if yyb13 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj13-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxWorkbookProtection) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(0)
			} else {
				r.WriteMapStart(0)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorkbookProtection) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorkbookProtection) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorkbookProtection) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = r.CheckBreak()
		}
		if yyb4 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxFileVersion) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.AppName))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `AppName`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.AppName))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LastEdited))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `LastEdited`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LastEdited))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LowestEdited))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `LowestEdited`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.LowestEdited))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RupBuild))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `RupBuild`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RupBuild))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxFileVersion) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxFileVersion) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "AppName":
			if r.TryDecodeAsNil() {
				x.AppName = ""
			} else {
				x.AppName = (string)(r.DecodeString())
			}
		case "LastEdited":
			if r.TryDecodeAsNil() {
				x.LastEdited = ""
			} else {
				x.LastEdited = (string)(r.DecodeString())
			}
		case "LowestEdited":
			if r.TryDecodeAsNil() {
				x.LowestEdited = ""
			} else {
				x.LowestEdited = (string)(r.DecodeString())
			}
		case "RupBuild":
			if r.TryDecodeAsNil() {
				x.RupBuild = ""
			} else {
				x.RupBuild = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxFileVersion) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AppName = ""
	} else {
		x.AppName = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.LastEdited = ""
	} else {
		x.LastEdited = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.LowestEdited = ""
	} else {
		x.LowestEdited = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.RupBuild = ""
	} else {
		x.RupBuild = (string)(r.DecodeString())
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxWorkbookPr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.DefaultThemeVersion))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefaultThemeVersion`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.DefaultThemeVersion))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.BackupFile))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `BackupFile`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.BackupFile))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ShowObjects))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowObjects`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ShowObjects))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Date1904))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Date1904`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Date1904))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorkbookPr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorkbookPr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "DefaultThemeVersion":
			if r.TryDecodeAsNil() {
				x.DefaultThemeVersion = ""
			} else {
				x.DefaultThemeVersion = (string)(r.DecodeString())
			}
		case "BackupFile":
			if r.TryDecodeAsNil() {
				x.BackupFile = false
			} else {
				x.BackupFile = (bool)(r.DecodeBool())
			}
		case "ShowObjects":
			if r.TryDecodeAsNil() {
				x.ShowObjects = ""
			} else {
				x.ShowObjects = (string)(r.DecodeString())
			}
		case "Date1904":
			if r.TryDecodeAsNil() {
				x.Date1904 = false
			} else {
				x.Date1904 = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorkbookPr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefaultThemeVersion = ""
	} else {
		x.DefaultThemeVersion = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BackupFile = false
	} else {
		x.BackupFile = (bool)(r.DecodeBool())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowObjects = ""
	} else {
		x.ShowObjects = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Date1904 = false
	} else {
		x.Date1904 = (bool)(r.DecodeBool())
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxBookViews) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.WorkBookView == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxWorkBookView(([]xlsxWorkBookView)(x.WorkBookView), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WorkBookView`)
				r.WriteMapElemValue()
				if x.WorkBookView == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxWorkBookView(([]xlsxWorkBookView)(x.WorkBookView), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxBookViews) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxBookViews) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "WorkBookView":
			if r.TryDecodeAsNil() {
				x.WorkBookView = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxWorkBookView((*[]xlsxWorkBookView)(&x.WorkBookView), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxBookViews) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WorkBookView = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxWorkBookView((*[]xlsxWorkBookView)(&x.WorkBookView), d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxWorkBookView) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(10)
			} else {
				r.WriteMapStart(10)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.ActiveTab))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ActiveTab`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.ActiveTab))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FirstSheet))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FirstSheet`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FirstSheet))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowHorizontalScroll))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowHorizontalScroll`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowHorizontalScroll))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowVerticalScroll))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowVerticalScroll`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowVerticalScroll))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowSheetTabs))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShowSheetTabs`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.ShowSheetTabs))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.TabRatio))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `TabRatio`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.TabRatio))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.WindowHeight))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WindowHeight`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.WindowHeight))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.WindowWidth))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WindowWidth`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.WindowWidth))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.XWindow))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `XWindow`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.XWindow))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.YWindow))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `YWindow`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.YWindow))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxWorkBookView) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxWorkBookView) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "ActiveTab":
			if r.TryDecodeAsNil() {
				x.ActiveTab = 0
			} else {
				x.ActiveTab = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FirstSheet":
			if r.TryDecodeAsNil() {
				x.FirstSheet = 0
			} else {
				x.FirstSheet = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "ShowHorizontalScroll":
			if r.TryDecodeAsNil() {
				x.ShowHorizontalScroll = false
			} else {
				x.ShowHorizontalScroll = (bool)(r.DecodeBool())
			}
		case "ShowVerticalScroll":
			if r.TryDecodeAsNil() {
				x.ShowVerticalScroll = false
			} else {
				x.ShowVerticalScroll = (bool)(r.DecodeBool())
			}
		case "ShowSheetTabs":
			if r.TryDecodeAsNil() {
				x.ShowSheetTabs = false
			} else {
				x.ShowSheetTabs = (bool)(r.DecodeBool())
			}
		case "TabRatio":
			if r.TryDecodeAsNil() {
				x.TabRatio = 0
			} else {
				x.TabRatio = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "WindowHeight":
			if r.TryDecodeAsNil() {
				x.WindowHeight = 0
			} else {
				x.WindowHeight = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "WindowWidth":
			if r.TryDecodeAsNil() {
				x.WindowWidth = 0
			} else {
				x.WindowWidth = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "XWindow":
			if r.TryDecodeAsNil() {
				x.XWindow = ""
			} else {
				x.XWindow = (string)(r.DecodeString())
			}
		case "YWindow":
			if r.TryDecodeAsNil() {
				x.YWindow = ""
			} else {
				x.YWindow = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxWorkBookView) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ActiveTab = 0
	} else {
		x.ActiveTab = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FirstSheet = 0
	} else {
		x.FirstSheet = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowHorizontalScroll = false
	} else {
		x.ShowHorizontalScroll = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowVerticalScroll = false
	} else {
		x.ShowVerticalScroll = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShowSheetTabs = false
	} else {
		x.ShowSheetTabs = (bool)(r.DecodeBool())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TabRatio = 0
	} else {
		x.TabRatio = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WindowHeight = 0
	} else {
		x.WindowHeight = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WindowWidth = 0
	} else {
		x.WindowWidth = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.XWindow = ""
	} else {
		x.XWindow = (string)(r.DecodeString())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.YWindow = ""
	} else {
		x.YWindow = (string)(r.DecodeString())
	}
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = r.CheckBreak()
		}
		if yyb14 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheets) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.Sheet == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSheet(([]xlsxSheet)(x.Sheet), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Sheet`)
				r.WriteMapElemValue()
				if x.Sheet == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxSheet(([]xlsxSheet)(x.Sheet), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheets) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheets) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Sheet":
			if r.TryDecodeAsNil() {
				x.Sheet = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxSheet((*[]xlsxSheet)(&x.Sheet), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheets) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sheet = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxSheet((*[]xlsxSheet)(&x.Sheet), d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxSheet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(4)
			} else {
				r.WriteMapStart(4)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.SheetId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `SheetId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.SheetId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Id))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Id`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Id))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.State))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `State`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.State))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxSheet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxSheet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = ""
			} else {
				x.Name = (string)(r.DecodeString())
			}
		case "SheetId":
			if r.TryDecodeAsNil() {
				x.SheetId = ""
			} else {
				x.SheetId = (string)(r.DecodeString())
			}
		case "Id":
			if r.TryDecodeAsNil() {
				x.Id = ""
			} else {
				x.Id = (string)(r.DecodeString())
			}
		case "State":
			if r.TryDecodeAsNil() {
				x.State = ""
			} else {
				x.State = (string)(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxSheet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = ""
	} else {
		x.Name = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SheetId = ""
	} else {
		x.SheetId = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Id = ""
	} else {
		x.Id = (string)(r.DecodeString())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.State = ""
	} else {
		x.State = (string)(r.DecodeString())
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxDefinedNames) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(1)
			} else {
				r.WriteMapStart(1)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if x.DefinedName == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxDefinedName(([]xlsxDefinedName)(x.DefinedName), e)
					}
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `DefinedName`)
				r.WriteMapElemValue()
				if x.DefinedName == nil {
					r.EncodeNil()
				} else {
					if false {
					} else {
						h.encSlicexlsxDefinedName(([]xlsxDefinedName)(x.DefinedName), e)
					}
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxDefinedNames) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxDefinedNames) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "DefinedName":
			if r.TryDecodeAsNil() {
				x.DefinedName = nil
			} else {
				if false {
				} else {
					h.decSlicexlsxDefinedName((*[]xlsxDefinedName)(&x.DefinedName), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxDefinedNames) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.DefinedName = nil
	} else {
		if false {
		} else {
			h.decSlicexlsxDefinedName((*[]xlsxDefinedName)(&x.DefinedName), d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxDefinedName) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(16)
			} else {
				r.WriteMapStart(16)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Data))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Data`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Data))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Name`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Name))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Comment))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Comment`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Comment))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.CustomMenu))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CustomMenu`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.CustomMenu))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Description))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Description`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Description))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Help))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Help`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.Help))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ShortcutKey))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `ShortcutKey`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.ShortcutKey))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.StatusBar))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `StatusBar`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.StatusBar))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.LocalSheetID))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `LocalSheetID`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.LocalSheetID))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.FunctionGroupID))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `FunctionGroupID`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.FunctionGroupID))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Function))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Function`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Function))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Hidden`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Hidden))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.VbProcedure))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `VbProcedure`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.VbProcedure))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.PublishToServer))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `PublishToServer`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.PublishToServer))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.WorkbookParameter))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `WorkbookParameter`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.WorkbookParameter))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Xlm))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Xlm`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Xlm))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxDefinedName) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxDefinedName) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "Data":
			if r.TryDecodeAsNil() {
				x.Data = ""
			} else {
				x.Data = (string)(r.DecodeString())
			}
		case "Name":
			if r.TryDecodeAsNil() {
				x.Name = ""
			} else {
				x.Name = (string)(r.DecodeString())
			}
		case "Comment":
			if r.TryDecodeAsNil() {
				x.Comment = ""
			} else {
				x.Comment = (string)(r.DecodeString())
			}
		case "CustomMenu":
			if r.TryDecodeAsNil() {
				x.CustomMenu = ""
			} else {
				x.CustomMenu = (string)(r.DecodeString())
			}
		case "Description":
			if r.TryDecodeAsNil() {
				x.Description = ""
			} else {
				x.Description = (string)(r.DecodeString())
			}
		case "Help":
			if r.TryDecodeAsNil() {
				x.Help = ""
			} else {
				x.Help = (string)(r.DecodeString())
			}
		case "ShortcutKey":
			if r.TryDecodeAsNil() {
				x.ShortcutKey = ""
			} else {
				x.ShortcutKey = (string)(r.DecodeString())
			}
		case "StatusBar":
			if r.TryDecodeAsNil() {
				x.StatusBar = ""
			} else {
				x.StatusBar = (string)(r.DecodeString())
			}
		case "LocalSheetID":
			if r.TryDecodeAsNil() {
				x.LocalSheetID = 0
			} else {
				x.LocalSheetID = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "FunctionGroupID":
			if r.TryDecodeAsNil() {
				x.FunctionGroupID = 0
			} else {
				x.FunctionGroupID = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "Function":
			if r.TryDecodeAsNil() {
				x.Function = false
			} else {
				x.Function = (bool)(r.DecodeBool())
			}
		case "Hidden":
			if r.TryDecodeAsNil() {
				x.Hidden = false
			} else {
				x.Hidden = (bool)(r.DecodeBool())
			}
		case "VbProcedure":
			if r.TryDecodeAsNil() {
				x.VbProcedure = false
			} else {
				x.VbProcedure = (bool)(r.DecodeBool())
			}
		case "PublishToServer":
			if r.TryDecodeAsNil() {
				x.PublishToServer = false
			} else {
				x.PublishToServer = (bool)(r.DecodeBool())
			}
		case "WorkbookParameter":
			if r.TryDecodeAsNil() {
				x.WorkbookParameter = false
			} else {
				x.WorkbookParameter = (bool)(r.DecodeBool())
			}
		case "Xlm":
			if r.TryDecodeAsNil() {
				x.Xlm = false
			} else {
				x.Xlm = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxDefinedName) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj20 int
	var yyb20 bool
	var yyhl20 bool = l >= 0
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Data = ""
	} else {
		x.Data = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Name = ""
	} else {
		x.Name = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Comment = ""
	} else {
		x.Comment = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CustomMenu = ""
	} else {
		x.CustomMenu = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Description = ""
	} else {
		x.Description = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Help = ""
	} else {
		x.Help = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ShortcutKey = ""
	} else {
		x.ShortcutKey = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.StatusBar = ""
	} else {
		x.StatusBar = (string)(r.DecodeString())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.LocalSheetID = 0
	} else {
		x.LocalSheetID = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.FunctionGroupID = 0
	} else {
		x.FunctionGroupID = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Function = false
	} else {
		x.Function = (bool)(r.DecodeBool())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Hidden = false
	} else {
		x.Hidden = (bool)(r.DecodeBool())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.VbProcedure = false
	} else {
		x.VbProcedure = (bool)(r.DecodeBool())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.PublishToServer = false
	} else {
		x.PublishToServer = (bool)(r.DecodeBool())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WorkbookParameter = false
	} else {
		x.WorkbookParameter = (bool)(r.DecodeBool())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = r.CheckBreak()
	}
	if yyb20 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Xlm = false
	} else {
		x.Xlm = (bool)(r.DecodeBool())
	}
	for {
		yyj20++
		if yyhl20 {
			yyb20 = yyj20 > l
		} else {
			yyb20 = r.CheckBreak()
		}
		if yyb20 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj20-1, "")
	}
	r.ReadArrayEnd()
}

func (x *xlsxCalcPr) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if false {
		} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
			z.EncExtension(x, yyxt1)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				r.WriteArrayStart(5)
			} else {
				r.WriteMapStart(5)
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.CalcId))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `CalcId`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.CalcId))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeInt(int64(x.IterateCount))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `IterateCount`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeInt(int64(x.IterateCount))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RefMode))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `RefMode`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeString(codecSelferCcUTF81, string(x.RefMode))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeBool(bool(x.Iterate))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `Iterate`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeBool(bool(x.Iterate))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayElem()
				if false {
				} else {
					r.EncodeFloat64(float64(x.IterateDelta))
				}
			} else {
				r.WriteMapElemKey()
				r.EncodeString(codecSelferCcUTF81, `IterateDelta`)
				r.WriteMapElemValue()
				if false {
				} else {
					r.EncodeFloat64(float64(x.IterateDelta))
				}
			}
			if yyr2 || yy2arr2 {
				r.WriteArrayEnd()
			} else {
				r.WriteMapEnd()
			}
		}
	}
}

func (x *xlsxCalcPr) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if false {
	} else if yyxt1 := z.Extension(z.I2Rtid(x)); yyxt1 != nil {
		z.DecExtension(x, yyxt1)
	} else {
		yyct2 := r.ContainerType()
		if yyct2 == codecSelferValueTypeMap1 {
			yyl2 := r.ReadMapStart()
			if yyl2 == 0 {
				r.ReadMapEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl2, d)
			}
		} else if yyct2 == codecSelferValueTypeArray1 {
			yyl2 := r.ReadArrayStart()
			if yyl2 == 0 {
				r.ReadArrayEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl2, d)
			}
		} else {
			panic(errCodecSelferOnlyMapOrArrayEncodeToStruct1)
		}
	}
}

func (x *xlsxCalcPr) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		r.ReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		r.ReadMapElemValue()
		switch yys3 {
		case "CalcId":
			if r.TryDecodeAsNil() {
				x.CalcId = ""
			} else {
				x.CalcId = (string)(r.DecodeString())
			}
		case "IterateCount":
			if r.TryDecodeAsNil() {
				x.IterateCount = 0
			} else {
				x.IterateCount = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
			}
		case "RefMode":
			if r.TryDecodeAsNil() {
				x.RefMode = ""
			} else {
				x.RefMode = (string)(r.DecodeString())
			}
		case "Iterate":
			if r.TryDecodeAsNil() {
				x.Iterate = false
			} else {
				x.Iterate = (bool)(r.DecodeBool())
			}
		case "IterateDelta":
			if r.TryDecodeAsNil() {
				x.IterateDelta = 0
			} else {
				x.IterateDelta = (float64)(r.DecodeFloat64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	r.ReadMapEnd()
}

func (x *xlsxCalcPr) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.CalcId = ""
	} else {
		x.CalcId = (string)(r.DecodeString())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.IterateCount = 0
	} else {
		x.IterateCount = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize1))
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.RefMode = ""
	} else {
		x.RefMode = (string)(r.DecodeString())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Iterate = false
	} else {
		x.Iterate = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayElem()
	if r.TryDecodeAsNil() {
		x.IterateDelta = 0
	} else {
		x.IterateDelta = (float64)(r.DecodeFloat64())
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		r.ReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	r.ReadArrayEnd()
}

func (x codecSelfer1) encWorkBookRels(v WorkBookRels, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		r.WriteMapElemKey()
		if false {
		} else {
			r.EncodeString(codecSelferCcUTF81, string(yyk1))
		}
		r.WriteMapElemValue()
		if false {
		} else {
			r.EncodeString(codecSelferCcUTF81, string(yyv1))
		}
	}
	r.WriteMapEnd()
}

func (x codecSelfer1) decWorkBookRels(v *WorkBookRels, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := r.ReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 32)
		yyv1 = make(map[string]string, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 string
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			r.ReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(r.DecodeString())
			}

			if yymg1 {
				yymv1 = yyv1[yymk1]
			}
			r.ReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1 = (string)(r.DecodeString())
			}

			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = ""
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	r.ReadMapEnd()
}

func (x codecSelfer1) encSlicexlsxOddHeader(v []xlsxOddHeader, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxOddHeader(v *[]xlsxOddHeader, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxOddHeader{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxOddHeader, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxOddHeader, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxOddHeader{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxOddHeader{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxOddHeader, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxOddFooter(v []xlsxOddFooter, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxOddFooter(v *[]xlsxOddFooter, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxOddFooter{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxOddFooter, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxOddFooter, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxOddFooter{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxOddFooter{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxOddFooter, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxSheetView(v []xlsxSheetView, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxSheetView(v *[]xlsxSheetView, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxSheetView{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 120)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxSheetView, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 120)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxSheetView, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxSheetView{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxSheetView{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxSheetView, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxSelection(v []xlsxSelection, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxSelection(v *[]xlsxSelection, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxSelection{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 56)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxSelection, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 56)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxSelection, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxSelection{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxSelection{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxSelection, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxPageSetUpPr(v []xlsxPageSetUpPr, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxPageSetUpPr(v *[]xlsxPageSetUpPr, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxPageSetUpPr{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 1)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxPageSetUpPr, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 1)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxPageSetUpPr, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxPageSetUpPr{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxPageSetUpPr{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxPageSetUpPr, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxCol(v []xlsxCol, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxCol(v *[]xlsxCol, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxCol{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 48)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxCol, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 48)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxCol, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxCol{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxCol{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxCol, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxRow(v []xlsxRow, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxRow(v *[]xlsxRow, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxRow{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 80)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxRow, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 80)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxRow, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxRow{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxRow{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxRow, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxC(v []xlsxC, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxC(v *[]xlsxC, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxC{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 72)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxC, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 72)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxC, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxC{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxC{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxC, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxMergeCell(v []xlsxMergeCell, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxMergeCell(v *[]xlsxMergeCell, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxMergeCell{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxMergeCell, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxMergeCell, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxMergeCell{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxMergeCell{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxMergeCell, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxSI(v []xlsxSI, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxSI(v *[]xlsxSI, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxSI{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 40)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxSI, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 40)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxSI, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxSI{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxSI{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxSI, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxR(v []xlsxR, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxR(v *[]xlsxR, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxR{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxR, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxR, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxR{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxR{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxR, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxOverride(v []xlsxOverride, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxOverride(v *[]xlsxOverride, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxOverride{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 32)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxOverride, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 32)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxOverride, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxOverride{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxOverride{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxOverride, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxDefault(v []xlsxDefault, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxDefault(v *[]xlsxDefault, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxDefault{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 32)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxDefault, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 32)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxDefault, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxDefault{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxDefault{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxDefault, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxNumFmt(v []xlsxNumFmt, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxNumFmt(v *[]xlsxNumFmt, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxNumFmt{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxNumFmt, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxNumFmt, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxNumFmt{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxNumFmt{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxNumFmt, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxFont(v []xlsxFont, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxFont(v *[]xlsxFont, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxFont{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 120)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxFont, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 120)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxFont, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxFont{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxFont{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxFont, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxFill(v []xlsxFill, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxFill(v *[]xlsxFill, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxFill{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 80)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxFill, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 80)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxFill, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxFill{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxFill{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxFill, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxBorder(v []xlsxBorder, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxBorder(v *[]xlsxBorder, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxBorder{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 192)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxBorder, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 192)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxBorder, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxBorder{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxBorder{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxBorder, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxCellStyle(v []xlsxCellStyle, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxCellStyle(v *[]xlsxCellStyle, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxCellStyle{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 88)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxCellStyle, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 88)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxCellStyle, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxCellStyle{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxCellStyle{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxCellStyle, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxXf(v []xlsxXf, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxXf(v *[]xlsxXf, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxXf{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 112)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxXf, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 112)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxXf, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxXf{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxXf{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxXf, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxClrSchemeEl(v []xlsxClrSchemeEl, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxClrSchemeEl(v *[]xlsxClrSchemeEl, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxClrSchemeEl{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 48)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxClrSchemeEl, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 48)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxClrSchemeEl, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxClrSchemeEl{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxClrSchemeEl{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxClrSchemeEl, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicePtrtoSheet(v []*Sheet, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicePtrtoSheet(v *[]*Sheet, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Sheet{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Sheet, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Sheet, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Sheet)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Sheet, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encMapstringPtrtoSheet(v map[string]*Sheet, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		r.WriteMapElemKey()
		if false {
		} else {
			r.EncodeString(codecSelferCcUTF81, string(yyk1))
		}
		r.WriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	r.WriteMapEnd()
}

func (x codecSelfer1) decMapstringPtrtoSheet(v *map[string]*Sheet, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := r.ReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 24)
		yyv1 = make(map[string]*Sheet, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 *Sheet
	var yymg1, yymdn1, yyms1, yymok1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			r.ReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(r.DecodeString())
			}

			yyms1 = true
			if yymg1 {
				yymv1, yymok1 = yyv1[yymk1]
				if yymok1 {
					yyms1 = false
				}
			} else {
				yymv1 = nil
			}
			r.ReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				if yymv1 == nil {
					yymv1 = new(Sheet)
				}
				yymv1.CodecDecodeSelf(d)
			}

			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyms1 && yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	r.ReadMapEnd()
}

func (x codecSelfer1) encSlicePtrtoxlsxDefinedName(v []*xlsxDefinedName, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicePtrtoxlsxDefinedName(v *[]*xlsxDefinedName, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*xlsxDefinedName{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*xlsxDefinedName, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*xlsxDefinedName, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(xlsxDefinedName)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*xlsxDefinedName, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicePtrtoRow(v []*Row, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicePtrtoRow(v *[]*Row, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Row{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Row, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Row, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Row)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Row, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicePtrtoCol(v []*Col, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicePtrtoCol(v *[]*Col, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Col{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Col, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Col, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Col)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Col, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSliceSheetView(v []SheetView, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSliceSheetView(v *[]SheetView, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []SheetView{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]SheetView, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]SheetView, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, SheetView{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = SheetView{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]SheetView, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicePtrtoCell(v []*Cell, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicePtrtoCell(v *[]*Cell, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Cell{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Cell, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Cell, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Cell)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Cell, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxWorkbookRelation(v []xlsxWorkbookRelation, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxWorkbookRelation(v *[]xlsxWorkbookRelation, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxWorkbookRelation{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 48)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxWorkbookRelation, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 48)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxWorkbookRelation, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxWorkbookRelation{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxWorkbookRelation{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxWorkbookRelation, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxWorkBookView(v []xlsxWorkBookView, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxWorkBookView(v *[]xlsxWorkBookView, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxWorkBookView{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 80)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxWorkBookView, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 80)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxWorkBookView, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxWorkBookView{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxWorkBookView{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxWorkBookView, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxSheet(v []xlsxSheet, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxSheet(v *[]xlsxSheet, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxSheet{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 64)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxSheet, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 64)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxSheet, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxSheet{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxSheet{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxSheet, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer1) encSlicexlsxDefinedName(v []xlsxDefinedName, e *codec1978.Encoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.WriteArrayStart(len(v))
	for _, yyv1 := range v {
		r.WriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	r.WriteArrayEnd()
}

func (x codecSelfer1) decSlicexlsxDefinedName(v *[]xlsxDefinedName, d *codec1978.Decoder) {
	var h codecSelfer1
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []xlsxDefinedName{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 152)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]xlsxDefinedName, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		// var yydn1 bool
		for ; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 152)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]xlsxDefinedName, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)

			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, xlsxDefinedName{})
				yyc1 = true

			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = xlsxDefinedName{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}

			}

		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]xlsxDefinedName, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}
